[{"title":"vue基础笔记","url":"http://yoursite.com/2018/11/16/vue基础笔记/","content":"<h1 id=\"vue基础笔记\"><a href=\"#vue基础笔记\" class=\"headerlink\" title=\"vue基础笔记\"></a>vue基础笔记</h1><blockquote>\n<ul>\n<li>官方学习<a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">网站</a>  </li>\n</ul>\n</blockquote>\n<h2 id=\"v-if-nbsp-指令\"><a href=\"#v-if-nbsp-指令\" class=\"headerlink\" title=\"v-if&nbsp;指令\"></a>v-if&nbsp;指令</h2><blockquote>\n<ul>\n<li>条件渲染指令  </li>\n<li>如果ok==true 界面显示Yes,否则显示No  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class=\"line\">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后，否则它们将不会被识别  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class=\"line\">  A</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class=\"line\">  B</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class=\"line\">  C</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div v-else&gt;</span><br><span class=\"line\">  Not A/B/C</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Vue会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染，Vue为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的key属性，<strong>label</strong>元素仍然会被高效地复用，因为它们没有添加key属性。如果不添加key属性，那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<strong>input</strong>不会被替换掉——仅仅是替换了它的placeholder  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class=\"line\">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class=\"line\">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else&gt;</span><br><span class=\"line\">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class=\"line\">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n</blockquote>\n<h2 id=\"v-show-nbsp-指令\"><a href=\"#v-show-nbsp-指令\" class=\"headerlink\" title=\"v-show&nbsp;指令\"></a>v-show&nbsp;指令</h2><blockquote>\n<p>带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建  </p>\n</li>\n<li><p>v-show元素总是会被渲染，并且只是简单地基于 CSS 进行切换  </p>\n</li>\n<li><p>v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"v-for-nbsp-指令\"><a href=\"#v-for-nbsp-指令\" class=\"headerlink\" title=\"v-for&nbsp;指令\"></a>v-for&nbsp;指令</h2><blockquote>\n<ul>\n<li>v-for 指令根据一组数组的选项列表进行渲染，v-for 指令需要使用 <strong>item in items</strong>形式的特殊语法，items是源数据数组并且 item是数组元素迭代的别名  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;li v-for=&quot;(item,index) in items&quot;&gt;</span><br><span class=\"line\">    &#123;&#123;index+1&#125;&#125;-&#123;&#123; item.message &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var example = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    items: [</span><br><span class=\"line\">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class=\"line\">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>v-for可以迭代输出一个对象的属性  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;</span><br><span class=\"line\">  &lt;li v-for=&quot;(value, key) in object&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class=\"line\">  &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#v-for-object&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    object: &#123;</span><br><span class=\"line\">      firstName: &apos;John&apos;,</span><br><span class=\"line\">      lastName: &apos;Doe&apos;,</span><br><span class=\"line\">      age: 30</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"v-on-nbsp-指令\"><a href=\"#v-on-nbsp-指令\" class=\"headerlink\" title=\"v-on&nbsp;指令\"></a>v-on&nbsp;指令</h2><blockquote>\n<ul>\n<li>v-on指令监听DOM事件，并在触发时运行JavaScript代码,可以使用@简写  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var example = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    name: &apos;Vue.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    greet: function (event) &#123;</span><br><span class=\"line\">      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)</span><br><span class=\"line\">      if (event) &#123;</span><br><span class=\"line\">        alert(event.target.tagName)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"v-model-nbsp-指令\"><a href=\"#v-model-nbsp-指令\" class=\"headerlink\" title=\"v-model&nbsp;指令\"></a>v-model&nbsp;指令</h2><blockquote>\n<ul>\n<li>v-model 指令在表单 input、textarea及select等元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素，它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class=\"line\">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example-4&quot;&gt;</span><br><span class=\"line\">  &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;</span><br><span class=\"line\">  &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;</span><br><span class=\"line\">  &lt;br&gt;</span><br><span class=\"line\">  &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;</span><br><span class=\"line\">  &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;</span><br><span class=\"line\">  &lt;br&gt;</span><br><span class=\"line\">  &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example-4&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    picked: &apos;&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"v-bind-nbsp-指令\"><a href=\"#v-bind-nbsp-指令\" class=\"headerlink\" title=\"v-bind&nbsp;指令\"></a>v-bind&nbsp;指令</h2><blockquote>\n<ul>\n<li>用来绑定元素属性,也就是Class与Style的绑定，可以简写为：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">  classObject: &#123;</span><br><span class=\"line\">    active: true,</span><br><span class=\"line\">    &apos;text-danger&apos;: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><blockquote>\n<ul>\n<li>可以将fullname看成data域中的属性一样，不过fullname属性随着firstName与lastName的改变而改成，修改fullname也会相应改变firstName与lastName。另外需要注意的是：计算属性是基于它们的依赖进行缓存的，只在相关依赖发生改变时它们才会重新求值，也就是说只有firstName与lastName发生了改变，我们get获取fullname时才会重新执行函数获取新的fullname值。<br><em>为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！</em><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    fullName: &#123;</span><br><span class=\"line\">        // getter</span><br><span class=\"line\">        get: function () &#123;</span><br><span class=\"line\">        return this.firstName + &apos; &apos; + this.lastName</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // setter</span><br><span class=\"line\">        set: function (newValue) &#123;</span><br><span class=\"line\">        var names = newValue.split(&apos; &apos;)</span><br><span class=\"line\">        this.firstName = names[0]</span><br><span class=\"line\">        this.lastName = names[names.length - 1]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h2><blockquote>\n<ul>\n<li>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Foo&apos;,</span><br><span class=\"line\">    lastName: &apos;Bar&apos;,</span><br><span class=\"line\">    fullName: &apos;Foo Bar&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    firstName: function (newval,oldval) &#123;</span><br><span class=\"line\">      this.fullName = newval + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    lastName: function (newval,oldval) &#123;</span><br><span class=\"line\">      this.fullName = this.firstName + &apos; &apos; + newval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>watch和computed可以从缓存中读数据，性能较好，只要相关数据没有改变就不执行；方法性能不好，只要页面数据有改变，方法就会执行。对于某种功能，三者都能实现读情况下，优先选computed  </li>\n</ul>\n</blockquote>\n<h2 id=\"添加组件\"><a href=\"#添加组件\" class=\"headerlink\" title=\"添加组件\"></a>添加组件</h2><blockquote>\n<ul>\n<li>在vue-cli组件配置与使用分为：引入组件、注册组件、使用组件  </li>\n<li>main.js是整个项目的入口文件,在src文件夹下,import引入vue和根组件app.vue,最后new Vue，启动应用</li>\n<li>自己定义的组件Hello.vue一般放到components目录下  </li>\n<li>父组件引入子组件，注册组件，使用组件  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步：在components目录下建立Hello.vue文件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">      &#123;&#123;message&#125;&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return&#123;</span><br><span class=\"line\">      message:&quot;hello&quot;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：在需要使用的子组件的地方中注册与使用组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">      &lt;abc&gt;&lt;/abc&gt;   //使用组件</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import Hello from &quot;./components/Hello&quot;   //导入子组件</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  components:&#123;      //注册组件</span><br><span class=\"line\">    abc:Hello</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return&#123;</span><br><span class=\"line\">      message:&quot;hello&quot;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"使用vue-router\"><a href=\"#使用vue-router\" class=\"headerlink\" title=\"使用vue-router\"></a>使用vue-router</h2><blockquote>\n<ul>\n<li>需要使用cnpm安装vue-router  </li>\n<li>在src/router/index.js中定义路由  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Router from &apos;vue-router&apos;</span><br><span class=\"line\">import Hello from &apos;../components/Hello&apos;   //首页</span><br><span class=\"line\">import Test from &apos;../components/test&apos;    //需要跳转的页面 给组件重新命名</span><br><span class=\"line\"> </span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"> </span><br><span class=\"line\">export default new Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;        //首页</span><br><span class=\"line\">      path: &apos;/&apos;,</span><br><span class=\"line\">      name: &apos;Hello&apos;,</span><br><span class=\"line\">      component: Hello</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;        //需要跳转的页面</span><br><span class=\"line\">        path:&apos;/test&apos;,</span><br><span class=\"line\">        name:&apos;test&apos;,</span><br><span class=\"line\">        component:Test    //组件名字</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>在app.vue中配置路由  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">    &lt;router-link to=&quot;/home&quot;&gt;home&lt;/router-link&gt;//跳转首页</span><br><span class=\"line\">    &lt;router-link to=&quot;/test&quot;&gt;test&lt;/router-link&gt;//跳转新页面</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;//页面渲染放置的部分</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;app&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#app &#123;</span><br><span class=\"line\">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class=\"line\">  -webkit-font-smoothing: antialiased;</span><br><span class=\"line\">  -moz-osx-font-smoothing: grayscale;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  color: #2c3e50;</span><br><span class=\"line\">  margin-top: 60px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>配置main.js  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import App from &apos;./App&apos;</span><br><span class=\"line\">import router from &apos;./router&apos;</span><br><span class=\"line\"> </span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\"> </span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;).$mount(&apos;#app&apos;)//实例挂载到元素中</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":[],"tags":[]},{"title":"vue开发环境搭建笔记","url":"http://yoursite.com/2018/11/13/vue开发环境搭建笔记/","content":"<h1 id=\"vue开发环境搭建笔记\"><a href=\"#vue开发环境搭建笔记\" class=\"headerlink\" title=\"vue开发环境搭建笔记\"></a>vue开发环境搭建笔记</h1><blockquote>\n<p>Vue.js是一套构建用户界面的 “渐进式框架”，核心库只关注视图层,提供试图与数据的双向绑定  </p>\n</blockquote>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><blockquote>\n<ul>\n<li><p>node.js官方<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载地址</a>  </p>\n</li>\n<li><p>安装操作系统对应版本的node.js  </p>\n</li>\n<li><p>安装过程中如果出现添加环境变量选项必须选上  </p>\n</li>\n<li><p>安装结束控制台输入<strong>node</strong>或<strong>npm</strong>命令，命令执行成功表示node安装成功  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"安装cnpm\"><a href=\"#安装cnpm\" class=\"headerlink\" title=\"安装cnpm\"></a>安装cnpm</h2><blockquote>\n<p>由于npm下载包非常的忙，安装国内代理cnpm工具  </p>\n<ul>\n<li><p>安装命令为：<strong>npm install -g cnpm –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></strong>  </p>\n</li>\n<li><p>以后需要使用npm命令的地方可以替换为cnpm命令  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"安装vue-cli\"><a href=\"#安装vue-cli\" class=\"headerlink\" title=\"安装vue-cli\"></a>安装vue-cli</h2><blockquote>\n<p>vue-cli是vue官方提供的一个命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程  </p>\n<ul>\n<li><p>安装命令为：<strong>cnpm install -g vue-cli</strong>  </p>\n</li>\n<li><p>检查是否安装成功可以在控制台输入vue，命令执行成功表示node安装成功  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"新建Vue项目\"><a href=\"#新建Vue项目\" class=\"headerlink\" title=\"新建Vue项目\"></a>新建Vue项目</h2><blockquote>\n<ul>\n<li><p><strong>vue init webpack vue-demo</strong>&nbsp;&nbsp;(vue-demo为项目名字)  </p>\n</li>\n<li><p>按照脚手架工具配置项目信息<br><img src=\"vue1.png\" alt=\"图片\">  </p>\n</li>\n<li><p>进入项目根目录执行<strong>cnpm install</strong>命令,安装项目依赖的包,安装完成之后，项目目录下多出node_modules文件夹  </p>\n</li>\n<li><p>根目录执行<strong>cnpm run dev</strong>命令，运行项目</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"iView介绍\"><a href=\"#iView介绍\" class=\"headerlink\" title=\"iView介绍\"></a>iView介绍</h2><blockquote>\n<ul>\n<li><p>iView<a href=\"https://www.iviewui.com/\" target=\"_blank\" rel=\"noopener\">官网</a>，iView组件是一套基于vue的前端组件库，可以帮助前端工作者快速开发美观的前端界面</p>\n</li>\n<li><p>iView提供完整的教程，上手简单快速  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"在项目中引入iView\"><a href=\"#在项目中引入iView\" class=\"headerlink\" title=\"在项目中引入iView\"></a>在项目中引入iView</h2><blockquote>\n<ul>\n<li>在main.js中添加  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import iView from &apos;iview&apos;</span><br><span class=\"line\">import &apos;iview/dist/styles/iview.css&apos;    // 使用 CSS</span><br><span class=\"line\">Vue.use(iView)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>完整main.js文件  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import App from &apos;./App&apos;</span><br><span class=\"line\">import router from &apos;./router&apos;</span><br><span class=\"line\">import iView from &apos;iview&apos;</span><br><span class=\"line\">import &apos;iview/dist/styles/iview.css&apos;    // 使用 CSS</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = false</span><br><span class=\"line\">Vue.use(iView)</span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>安装iView，<strong>cnpm install –save iview</strong>  </li>\n</ul>\n</blockquote>\n<h2 id=\"Vue中引入axios\"><a href=\"#Vue中引入axios\" class=\"headerlink\" title=\"Vue中引入axios\"></a>Vue中引入axios</h2><blockquote>\n<ul>\n<li><p>axios是一个基于promise的HTTP库，可以用在前端和后台中获取数据  </p>\n</li>\n<li><p>安装命令<strong>cnpm install axios</strong>  </p>\n</li>\n<li><p>组件局部引入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>全局引入,在main.js中添加,在各个组件中this.$axios.get()使用  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>axios使用demo,<em>采用在main.js中全局引入</em>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$axios.get(&quot;/asr/asrText&quot;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        deviceIdAndSessionId:_self.deviceId+&quot;:&quot;+_self.sessionId,</span><br><span class=\"line\">    &#125;&#125;).then(result =&gt; &#123;</span><br><span class=\"line\">          console.log(result);</span><br><span class=\"line\">          console.log(&quot;长度&quot;+result.data.length);</span><br><span class=\"line\">          console.log(&quot;刷新一次&quot;);</span><br><span class=\"line\">          this.asrText=result.data;</span><br><span class=\"line\">    &#125;).catch(err =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java线程池笔记","url":"http://yoursite.com/2018/11/08/java线程池笔记/","content":"<h1 id=\"Java线程池笔记\"><a href=\"#Java线程池笔记\" class=\"headerlink\" title=\"Java线程池笔记\"></a>Java线程池笔记</h1><blockquote>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，如果每个请求到达服务器就创建一个新线程为其服务，开销是相当大的。服务器在创建和销毁线程上花费的时间和消耗的系统资源非常大，甚至可能要比在处理实际的用请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或线程上下文切换过度而导致系统资源不足<br>&nbsp;&nbsp;&nbsp;&nbsp;线程池可以应对突然大爆发量的访问，通过有限个固定线程为大量的操作服务，减少创建和销毁线程所需的时间  </p>\n<p><strong>使用线程池好处：</strong>  </p>\n<ul>\n<li><p>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗  </p>\n</li>\n<li><p>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行  </p>\n</li>\n<li><p>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"线程池类\"><a href=\"#线程池类\" class=\"headerlink\" title=\"线程池类\"></a>线程池类</h2><blockquote>\n<p><img src=\"qw.jpeg\" alt=\"图片\">  </p>\n<p><img src=\"th1.png\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h2><blockquote>\n<p><em>通过工具类Executors的静态方法来获取线程池</em>  </p>\n<hr>\n<h3 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h3><p><strong>单例线程</strong>，表示在任意的时间段内，线程池中只有一个线程在工作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<hr>\n<h3 id=\"newCacheThreadPool\"><a href=\"#newCacheThreadPool\" class=\"headerlink\" title=\"newCacheThreadPool\"></a>newCacheThreadPool</h3><p><strong>缓存线程池</strong>，先查看线程池中是否有当前执行线程的缓存，如果有就resue(复用),如果没有,那么需要创建一个线程来完成当前的调用.并且这类线程池只能完成一些生存期很短的一些任务.并且这类线程池内部规定能resue(复用)的线程，空闲的时间不能超过60s,一旦超过了60s,就会被移出线程池<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<hr>\n<h3 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h3><p><strong>固定型线程池</strong>，和newCacheThreadPool()差不多，也能够实现resue(复用),但是这个池规定了线程的最大数量，也就是说当池有空闲时，那么新的任务将会在空闲线程中被执行，一旦线程池内的线程都在进行工作，那么新的任务就必须等待线程池有空闲的时候才能够进入线程池,其他的任务继续排队等待.这类池子没有规定其空闲的时间到底有多长.这一类的池更适用于服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newFixedThreadPool(10);</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<hr>\n<h3 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h3><p><strong>调度型线程池</strong>,调度型线程池会根据Scheduled(任务列表)进行延迟执行，或者是进行周期性的执行.适用于一些周期性的工作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newScheduledThreadPool(10);</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<h3 id=\"例程\"><a href=\"#例程\" class=\"headerlink\" title=\"例程\"></a>例程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.ExecutorService;</span><br><span class=\"line\">import java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class=\"line\">        service.submit(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                while(true)&#123;</span><br><span class=\"line\">                    System.out.println(&quot;hello world !&quot;);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(1000);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(&quot;main Thread execute here ! &quot; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><blockquote>\n<p>任务分为两种:<br>一种是有返回值的（<strong>callable</strong>），一种是没有返回值的（<strong>runnable</strong>）<br>Callable与 Future 两功能是Java在后续版本中为了适应多并法才加入的，Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其他线程执行的任务  </p>\n<ul>\n<li><p>无返回值的任务就是一个实现了runnable接口的类，覆盖run方法  </p>\n</li>\n<li><p>有返回值的任务是一个实现了callable接口的类，覆盖call方法  </p>\n</li>\n</ul>\n<p><strong>区别</strong>  </p>\n<ul>\n<li><p>Callable定义的方法是call，而Runnable定义的方法是run  </p>\n</li>\n<li><p>Callable的call方法可以有返回值，而Runnable的run方法不能有返回值  </p>\n</li>\n<li><p>Callable的call方法可抛出异常，而Runnable的run方法不能抛出异常  </p>\n<h2 id=\"与Callable配套的Future\"><a href=\"#与Callable配套的Future\" class=\"headerlink\" title=\"与Callable配套的Future\"></a>与Callable配套的Future</h2><p>Future表示异步计算的结果，它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果  </p>\n</li>\n<li><p><strong>Future.get()会阻塞当前的线程，等待Callable执行结束获取返回值</strong>  </p>\n</li>\n<li><p><strong>Future的cancel方法可以取消任务的执行，它有一布尔参数，参数为 true 表示立即中断任务的执行，参数为 false 表示允许正在运行的任务运行完成</strong>  </p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.Callable;</span><br><span class=\"line\">import java.util.concurrent.ExecutorService;</span><br><span class=\"line\">import java.util.concurrent.Executors;</span><br><span class=\"line\">import java.util.concurrent.Future;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CallableAndFuture &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class  MyCallable  implements Callable&#123;</span><br><span class=\"line\">        private int flag = 0;</span><br><span class=\"line\">        public MyCallable(int flag)&#123;</span><br><span class=\"line\">            this.flag = flag;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public String call() throws Exception&#123;</span><br><span class=\"line\">            if (this.flag == 0)&#123;</span><br><span class=\"line\">                return &quot;flag = 0&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (this.flag == 1)&#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    while (true) &#123;</span><br><span class=\"line\">                        System.out.println(&quot;looping.&quot;);</span><br><span class=\"line\">                        Thread.sleep(2000);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;Interrupted&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return &quot;false&quot;;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                throw new Exception(&quot;Bad flag value!&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 定义3个Callable类型的任务</span><br><span class=\"line\">        MyCallable task1 = new MyCallable(0);</span><br><span class=\"line\">        MyCallable task2 = new MyCallable(1);</span><br><span class=\"line\">        MyCallable task3 = new MyCallable(2);</span><br><span class=\"line\">        // 创建一个执行任务的线程池</span><br><span class=\"line\">        ExecutorService es = Executors.newFixedThreadPool(3);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 提交并执行任务，任务启动时返回了一个Future对象，</span><br><span class=\"line\">            // 如果想得到任务执行的结果或者是异常可对这个Future对象进行操作</span><br><span class=\"line\">            Future future1 = es.submit(task1);</span><br><span class=\"line\">            // 获得第一个任务的结果，如果调用get方法，当前线程会等待任务执行完毕后才往下执行</span><br><span class=\"line\">            System.out.println(&quot;task1: &quot; + future1.get());</span><br><span class=\"line\">            Future future2 = es.submit(task2);</span><br><span class=\"line\">            // 等待5秒后，再停止第二个任务。因为第二个任务进行的是无限循环</span><br><span class=\"line\">            Thread.sleep(5000);</span><br><span class=\"line\">            System.out.println(&quot;task2 cancel: &quot; + future2.cancel(true));</span><br><span class=\"line\">            // 获取第三个任务的输出，因为执行第三个任务会引起异常</span><br><span class=\"line\">            // 所以下面的语句将引起异常的抛出</span><br><span class=\"line\">            Future future3 = es.submit(task3);</span><br><span class=\"line\">            System.out.println(&quot;task3: &quot; + future3.get());</span><br><span class=\"line\">        &#125; catch (Exception e)&#123;</span><br><span class=\"line\">            System.out.println(e.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 停止任务执行服务</span><br><span class=\"line\">        es.shutdownNow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>线程池的execute与submit区别：</strong>  </p>\n<ul>\n<li><p>接收的参数不一样,execut接收runnable；submit接收Callable  </p>\n</li>\n<li><p>submit有返回值(Future对象)，而execute没有  </p>\n</li>\n<li><p>submit方便Exception处理  </p>\n</li>\n<li><p>execute是Executor接口中唯一定义的方法；submit是ExecutorService（该接口继承Executor）中定义的方法  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h2><blockquote>\n<ul>\n<li><p>shutdown()，shutdown并不是直接关闭线程池，而是不再接受新的任务…如果线程池内有任务，那么把这些任务执行完毕后，关闭线程池  </p>\n</li>\n<li><p>shutdownNow()，这个方法表示不再接受新的任务，并把任务队列中的任务直接移出掉，如果有正在执行的，尝试进行停止  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a>FutureTask</h2><blockquote>\n<p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //第一种方式</span><br><span class=\"line\">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class=\"line\">        Task task = new Task();</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class=\"line\">        executor.submit(futureTask);</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">         </span><br><span class=\"line\">        //第二种方式。一个是使用ExecutorService，一个使用的是Thread</span><br><span class=\"line\">        /*Task task = new Task();</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class=\"line\">        Thread thread = new Thread(futureTask);</span><br><span class=\"line\">        thread.start();*/</span><br><span class=\"line\">         </span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e1) &#123;</span><br><span class=\"line\">            e1.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        System.out.println(&quot;主线程在执行任务&quot;);</span><br><span class=\"line\">         </span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;task运行结果&quot;+futureTask.get());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        System.out.println(&quot;所有任务执行完毕&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Integer call() throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;子线程在进行计算&quot;);</span><br><span class=\"line\">        Thread.sleep(3000);</span><br><span class=\"line\">        int sum = 0;</span><br><span class=\"line\">        for(int i=0;i&lt;100;i++)</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><blockquote>\n<p>ThreadPoolExecutor是线程池的核心类,构造函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>corePoolSize，核心线程数量，线程池刚创建时，线程数量为0，当每次执行execute添加新的任务时会在线程池创建一个新的线程，直到线程数量达到corePoolSize为止。  </p>\n<p>workQueue，阻塞队列，当线程池正在运行的线程数量已经达到corePoolSize，那么再通过execute添加新的任务则会被加到workQueue队列中，在队列中排队等待执行，而不会立即执行。  </p>\n<p>maximumPoolSize，最大线程数量，当workQueue队列已满，放不下新的任务，再通过execute添加新的任务则线程池会再创建新的线程，线程数量大于corePoolSize但不会超过maximumPoolSize，如果超过maximumPoolSize，那么会抛出异常，如RejectedExecutionException。  </p>\n<p>keepAliveTime和unit，当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被销毁。unit则是keepAliveTime的时间单位  </p>\n</blockquote>\n<h2 id=\"Executor、ExecutorService、ThreadPoolExecutor区别\"><a href=\"#Executor、ExecutorService、ThreadPoolExecutor区别\" class=\"headerlink\" title=\"Executor、ExecutorService、ThreadPoolExecutor区别\"></a>Executor、ExecutorService、ThreadPoolExecutor区别</h2><blockquote>\n<ul>\n<li>源码非常简单，只有一个execute（Runnable command）回调接口  </li>\n<li>ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成Future的方法  </li>\n<li>ThreadPoolExecutor是ExecutorService的一个实现类，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java原子变量类笔记","url":"http://yoursite.com/2018/11/07/java原子变量类笔记/","content":"<h1 id=\"Java-原子变量类笔记\"><a href=\"#Java-原子变量类笔记\" class=\"headerlink\" title=\"Java 原子变量类笔记\"></a>Java 原子变量类笔记</h1><h2 id=\"原子操作硬件的实现原理\"><a href=\"#原子操作硬件的实现原理\" class=\"headerlink\" title=\"原子操作硬件的实现原理\"></a>原子操作硬件的实现原理</h2><blockquote>\n<p>在intel x86处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作  </p>\n<ul>\n<li><p>通过总线锁保证原子性，使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存  </p>\n</li>\n<li><p>通过缓存锁定来保证原子性，在同一时刻，我们只需保证对某个内存地址<br>的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化，所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"Java-CAS\"><a href=\"#Java-CAS\" class=\"headerlink\" title=\"Java CAS\"></a>Java CAS</h2><blockquote>\n<ul>\n<li><p>在Java中可以通过锁和循环CAS的方式来实现原子操作  </p>\n</li>\n<li><p>CAS通过调用JNI代码实现。JVM将CAS操作编译为底层提供的最有效方法。在支持CAS的处理器上，JVM 将它们编译为相应的机器指令；在不支持CAS的处理器上，JVM将使用自旋锁  </p>\n</li>\n<li><p>一般情况下，比锁性能更高。因为 CAS 是一种非阻塞算法，所以其避免了线程被阻塞时的等待时间</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"CAS操作\"><a href=\"#CAS操作\" class=\"headerlink\" title=\"CAS操作\"></a>CAS操作</h2><blockquote>\n<p><img src=\"kk1.PNG\" alt=\"图片\"><br>CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作  </p>\n</blockquote>\n<h2 id=\"原子变量类\"><a href=\"#原子变量类\" class=\"headerlink\" title=\"原子变量类\"></a>原子变量类</h2><blockquote>\n<ul>\n<li><p>原子变量比锁的粒度更细，量级更轻，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键  </p>\n</li>\n<li><p>原子类在内部使用现代CPU支持的CAS指令(cmpxchg)来实现同步。这些指令通常比锁更快  </p>\n</li>\n<li><p>java.util.concurrent.atomic包下面，采用了CAS机制来实现加锁  </p>\n</li>\n<li><p>atomic不会造成像使用lock、synchronized等线程频繁的上下文切换，造成由于频繁上下文切换带来的资源浪费  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"原子更新基本类型\"><a href=\"#原子更新基本类型\" class=\"headerlink\" title=\"原子更新基本类型\"></a>原子更新基本类型</h2><blockquote>\n<ul>\n<li>AtomicBoolean - 原子更新布尔类型  </li>\n<li>AtomicInteger - 原子更新整型  </li>\n<li>AtomicLong - 原子更新长整型  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AtomicIntegerDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class=\"line\">        AtomicInteger count = new AtomicInteger(0);</span><br><span class=\"line\">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            executorService.submit((Runnable) () -&gt; &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + &quot; count=&quot; + count.get());</span><br><span class=\"line\">                count.incrementAndGet();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">        executorService.awaitTermination(30, TimeUnit.SECONDS);</span><br><span class=\"line\">        System.out.println(&quot;Final Count is : &quot; + count.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"原子更新数组\"><a href=\"#原子更新数组\" class=\"headerlink\" title=\"原子更新数组\"></a>原子更新数组</h2><blockquote>\n<ul>\n<li>AtomicIntegerArray - 原子更新整型数组里的元素  </li>\n<li>AtomicLongArray - 原子更新长整型数组里的元素  </li>\n<li>AtomicReferenceArray - 原子更新引用类型数组的元素  </li>\n<li>AtomicBooleanArray - 原子更新布尔类型数组的元素  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AtomicIntegerArrayDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(final String[] arguments) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; atomicIntegerArray.length(); i++) &#123;</span><br><span class=\"line\">            atomicIntegerArray.set(i, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = new Thread(new Increment());</span><br><span class=\"line\">        Thread t2 = new Thread(new Compare());</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;Final Values: &quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; atomicIntegerArray.length(); i++) &#123;</span><br><span class=\"line\">            System.out.print(atomicIntegerArray.get(i) + &quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Increment implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            for (int i = 0; i &lt; atomicIntegerArray.length(); i++) &#123;</span><br><span class=\"line\">                int add = atomicIntegerArray.incrementAndGet(i);</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + &quot;, index &quot; + i + &quot;, value: &quot; + add);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Compare implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            for (int i = 0; i &lt; atomicIntegerArray.length(); i++) &#123;</span><br><span class=\"line\">                boolean swapped = atomicIntegerArray.compareAndSet(i, 2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">                if (swapped) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;, index &quot; + i + &quot;, value: 3&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"原子更新引用类型\"><a href=\"#原子更新引用类型\" class=\"headerlink\" title=\"原子更新引用类型\"></a>原子更新引用类型</h2><blockquote>\n<ul>\n<li>AtomicReference - 原子更新引用类型  </li>\n<li>AtomicReferenceFieldUpdater - 原子更新引用类型里的字段  </li>\n<li>AtomicMarkableReference - 原子更新带有标记位的引用类型  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AtomicReferenceDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static String message;</span><br><span class=\"line\">    private static Person person;</span><br><span class=\"line\">    private static AtomicReference&lt;String&gt; aRmessage;</span><br><span class=\"line\">    private static AtomicReference&lt;Person&gt; aRperson;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        Thread t1 = new Thread(new MyRun1());</span><br><span class=\"line\">        Thread t2 = new Thread(new MyRun2());</span><br><span class=\"line\">        message = &quot;hello&quot;;</span><br><span class=\"line\">        person = new Person(&quot;Phillip&quot;, 23);</span><br><span class=\"line\">        aRmessage = new AtomicReference&lt;String&gt;(message);</span><br><span class=\"line\">        aRperson = new AtomicReference&lt;Person&gt;(person);</span><br><span class=\"line\">        System.out.println(&quot;Message is: &quot; + message</span><br><span class=\"line\">            + &quot;\\nPerson is &quot; + person.toString());</span><br><span class=\"line\">        System.out.println(&quot;Atomic Reference of Message is: &quot; + aRmessage.get()</span><br><span class=\"line\">            + &quot;\\nAtomic Reference of Person is &quot; + aRperson.get().toString());</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(&quot;\\nNow Message is: &quot; + message</span><br><span class=\"line\">            + &quot;\\nPerson is &quot; + person.toString());</span><br><span class=\"line\">        System.out.println(&quot;Atomic Reference of Message is: &quot; + aRmessage.get()</span><br><span class=\"line\">            + &quot;\\nAtomic Reference of Person is &quot; + aRperson.get().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class MyRun1 implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            aRmessage.compareAndSet(message, &quot;Thread 1&quot;);</span><br><span class=\"line\">            message = message.concat(&quot;-Thread 1!&quot;);</span><br><span class=\"line\">            person.setAge(person.getAge() + 1);</span><br><span class=\"line\">            person.setName(&quot;Thread 1&quot;);</span><br><span class=\"line\">            aRperson.getAndSet(new Person(&quot;Thread 1&quot;, 1));</span><br><span class=\"line\">            System.out.println(&quot;\\n&quot; + Thread.currentThread().getName() + &quot; Values &quot;</span><br><span class=\"line\">                + message + &quot; - &quot; + person.toString());</span><br><span class=\"line\">            System.out.println(&quot;\\n&quot; + Thread.currentThread().getName() + &quot; Atomic References &quot;</span><br><span class=\"line\">                + message + &quot; - &quot; + person.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class MyRun2 implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            message = message.concat(&quot;-Thread 2&quot;);</span><br><span class=\"line\">            person.setAge(person.getAge() + 2);</span><br><span class=\"line\">            person.setName(&quot;Thread 2&quot;);</span><br><span class=\"line\">            aRmessage.lazySet(&quot;Thread 2&quot;);</span><br><span class=\"line\">            aRperson.set(new Person(&quot;Thread 2&quot;, 2));</span><br><span class=\"line\">            System.out.println(&quot;\\n&quot; + Thread.currentThread().getName() + &quot; Values: &quot;</span><br><span class=\"line\">                + message + &quot; - &quot; + person.toString());</span><br><span class=\"line\">            System.out.println(&quot;\\n&quot; + Thread.currentThread().getName() + &quot; Atomic References: &quot;</span><br><span class=\"line\">                + aRmessage.get() + &quot; - &quot; + aRperson.get().toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private String name;</span><br><span class=\"line\">        private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">        Person(String name, int age) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">            this.age = age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public String getName() &#123;</span><br><span class=\"line\">            return name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void setName(String name) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int getAge() &#123;</span><br><span class=\"line\">            return age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        void setAge(int age) &#123;</span><br><span class=\"line\">            this.age = age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;[name &quot; + this.name + &quot;, age &quot; + this.age + &quot;]&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"原子更新字段类\"><a href=\"#原子更新字段类\" class=\"headerlink\" title=\"原子更新字段类\"></a>原子更新字段类</h2><blockquote>\n<ul>\n<li>AtomicIntegerFieldUpdater - 原子更新整型的字段的更新器  </li>\n<li>AtomicLongFieldUpdater - 原子更新长整型字段的更新器  </li>\n<li>AtomicStampedReference - 原子更新带有版本号的引用类型。该类将整型数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AtomicStampedReferenceDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String INIT_REF = &quot;abc&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference&lt;&gt;(INIT_REF, 0);</span><br><span class=\"line\">        System.out.println(&quot;初始对象为：&quot; + asr.getReference());</span><br><span class=\"line\">        final int stamp = asr.getStamp();</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(Math.abs((int) (Math.random() * 100)));</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (asr.compareAndSet(INIT_REF, Thread.currentThread().getName(), stamp, stamp + 1)) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot; 修改了对象！&quot;);</span><br><span class=\"line\">                    System.out.println(&quot;新的对象为：&quot; + asr.getReference());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">        executorService.awaitTermination(60, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"volatile与Atomic原子操作的区别\"><a href=\"#volatile与Atomic原子操作的区别\" class=\"headerlink\" title=\"volatile与Atomic原子操作的区别\"></a>volatile与Atomic原子操作的区别</h2><blockquote>\n<ul>\n<li><p>volatile关键字是通过本地代码实现的写锁，只保证知有一个线程在写某个数据<br><em>JVM为了提高数据存取的速度，允许每个线程在自己独立的数据块，对进程中共享的数据进行私有拷贝。volatile就是保证每次读数据时，读的都是存在共享数据块里的数据，而不是私有拷贝</em>  </p>\n</li>\n<li><p>volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性<br><em>不能将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的</em>  </p>\n</li>\n<li><p>Atomic则通过一种线程安全的加减操作接口  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h2><blockquote>\n<ul>\n<li><p>synchronized：在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是合适的,原因在于，编译程序通常会尽可能的进行优化synchronize，另外程序的可读性非常好  </p>\n</li>\n<li><p>ReentrantLock：提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能与synchronized差不多。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍,而ReentrantLock确还能维持常态  </p>\n</li>\n<li><p>Atomic：的性能会优于ReentrantLock一倍左右。但是缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。在竞争激烈的时候，同步效果最好  </p>\n</li>\n<li><p>非常简单的操作且又不想引入锁可以考虑使用 CAS 操作，当想要非阻塞地完成某一操作也可以考虑 CAS。不推荐在复杂操作中引入 CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题  </p>\n</li>\n</ul>\n<p><strong>ABA问题：</strong> <em>因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B－3A。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</em></p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"netty线程模型","url":"http://yoursite.com/2018/11/06/netty线程模型/","content":"<h1 id=\"netty线程模型\"><a href=\"#netty线程模型\" class=\"headerlink\" title=\"netty线程模型\"></a>netty线程模型</h1><blockquote>\n<p>Reactor模型：异步非阻塞IO，所有的IO操作都不会导致阻塞</p>\n</blockquote>\n<h2 id=\"Reactor单线程模型\"><a href=\"#Reactor单线程模型\" class=\"headerlink\" title=\"Reactor单线程模型\"></a>Reactor单线程模型</h2><blockquote>\n<p>Reactor单线程模型，指所有的I/O操作都在同一个NIO线程上面完成：  </p>\n<p><img src=\"bg1.PNG\" alt=\"图片\"></p>\n<ul>\n<li><p>作为NIO服务端，接收客户端的TCP连接  </p>\n</li>\n<li><p>作为NIO客户端，向服务端发起TCP连接  </p>\n</li>\n<li><p>读取通信对端的请求或者应答数据  </p>\n</li>\n<li><p>向通信对端发送消息请求或者应答消息  </p>\n</li>\n</ul>\n<p>在小容量应用场景下，可以使用单线程模型，但是对于高负载，大并发的应用场景却并不合适:<br><img src=\"bg2.PNG\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"Reactor多线程模型\"><a href=\"#Reactor多线程模型\" class=\"headerlink\" title=\"Reactor多线程模型\"></a>Reactor多线程模型</h2><blockquote>\n<p>Reactor多线程模型通过增加一组NIO线程来处理IO操作  </p>\n<p><img src=\"bg3.PNG\" alt=\"图片\">  </p>\n<ul>\n<li><p>专门的NIO线程（acceptor线程）用于监听服务端，接收客户端的TCP连接请求  </p>\n</li>\n<li><p>网络IO操作（读写等）由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，这些线程池负责消息的读取，解码和发送  </p>\n</li>\n<li><p>一个NIO线程可以同时处理多条链路，但一条链路只对应一个NIO线程,防止发生并发操作问题  </p>\n</li>\n</ul>\n<p><img src=\"bg4.PNG\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"主从Reactor多线程模型\"><a href=\"#主从Reactor多线程模型\" class=\"headerlink\" title=\"主从Reactor多线程模型\"></a>主从Reactor多线程模型</h2><blockquote>\n<p><img src=\"bg5.PNG\" alt=\"图片\">  </p>\n<p>服务端用于接收客户端连接的不再是一个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求后并处理完成（包含接入认证等），将新创建的SocketChannel注册到IO线程池的某个IO线程上，由它负责SocketChannel的读写和编解码工作  </p>\n</blockquote>\n<h2 id=\"Netty线程模型\"><a href=\"#Netty线程模型\" class=\"headerlink\" title=\"Netty线程模型\"></a>Netty线程模型</h2><blockquote>\n<p><strong>Netty接收客户端请求线程池</strong>  </p>\n<ul>\n<li>接收客户端TCP连接，初始化Channel参数  </li>\n<li>将链路状态变更事件通知给ChannelPipeline  </li>\n</ul>\n<p><strong>Netty处理IO操作线程池</strong>  </p>\n<ul>\n<li>异步读取通信对端的数据报，发送读事件到ChannelPipeline  </li>\n<li>异步发送消息到通信对端，调用ChannelPipeline的消息发送接口  </li>\n<li>执行系统调用Task，定时任务  </li>\n</ul>\n<p>通过调整线程池的线程个数，是否共享线程池等，Netty的Reactor线程模型可以在单线程，多线程和主从多线程间切换  </p>\n</blockquote>\n<h2 id=\"Netty局部无锁优化\"><a href=\"#Netty局部无锁优化\" class=\"headerlink\" title=\"Netty局部无锁优化\"></a>Netty局部无锁优化</h2><blockquote>\n<p>Netty在IO线程内部进行串行操作，避免多线程竞争导致的性能下降问题，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，局部无锁化的设计模型在实际效果中表现最优：<br><strong>原理图:</strong><br><img src=\"bg6.PNG\" alt=\"图片\">  </p>\n<p><img src=\"bg7.PNG\" alt=\"图片\">  </p>\n<p>线程配置计算公式:  </p>\n<ul>\n<li><p>一：线程数量=(线程总事件/瓶颈资源时间)*瓶颈资源的线程并行数  </p>\n</li>\n<li><p>二：QPS=1000/线程总时间*线程数(每秒查询率QPS)  </p>\n</li>\n<li><p>线程数量配置以实际效果为准  </p>\n</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"concurrency组件笔记","url":"http://yoursite.com/2018/11/02/concurrency组件笔记/","content":"<h1 id=\"Java-Concurrency组件\"><a href=\"#Java-Concurrency组件\" class=\"headerlink\" title=\"Java Concurrency组件\"></a>Java Concurrency组件</h1><blockquote>\n<p>Java java.util.concurrent包是Java 5引入的，包含一组类，可以更容易地用Java开发并发（多线程）应用程序  </p>\n</blockquote>\n<h2 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h2><blockquote>\n<p>A BlockingQueue通常用于在线程上生成另一个线程消耗的对象: </p>\n<p><img src=\"cc1.PNG\" alt=\"图片\">  </p>\n<p>生成线程将生成新对象并将它们插入队列，直到队列达到它可以包含的内容的某个上限。换句话说，这是限制。如果阻塞队列达到其上限，则在尝试插入新对象时会阻止生成线程。它一直被阻塞，直到消费线程将一个对象从队列中取出。消费线程不断将对象从阻塞队列中取出并处理它们。如果消费线程尝试将对象从空队列中取出，则消耗线程将被阻塞，直到生成线程将对象放入队列。  </p>\n<p><em>无法插入null到BlockingQueue。如果您尝试插入null， BlockingQueue则会抛出一个NullPointerException</em><br> <strong>由于BlockingQueue是一个接口，您需要使用其中一个实现来使用它：</strong>  </p>\n<ul>\n<li>ArrayBlockingQueue  </li>\n<li>DelayQueue  </li>\n<li>PriorityBlockingQueue  </li>\n<li>SynchronousQueue</li>\n</ul>\n</blockquote>\n<h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><blockquote>\n<ul>\n<li><p>ArrayBlockingQueue类实现了BlockingQueue接口</p>\n</li>\n<li><p>ArrayBlockingQueue是一个有界的阻塞队列，它将元素内部存储在一个数组中。它有界意味着它无法存储无限量的元素。它可以同时存储的元素数量有一个上限。您在实例化时设置上限，之后无法更改。  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h2><blockquote>\n<ul>\n<li><p>DelayQueue实现BlockingQueue接口  </p>\n</li>\n<li><p>DelayQueue队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</p>\n</li>\n<li><p>在DelayQueue内部阻止元素直到某个延迟到期。元素必须实现接口java.util.concurrent.Delayed。以下是界面的外观：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Delayed extends Comparable&lt;Delayed&lt; &#123;</span><br><span class=\"line\">    public long getDelay(TimeUnit timeUnit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>getDelay()方法 返回的值应该是在释放此元素之前剩余的延迟  </p>\n<p><strong>Demo:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DelayQueueExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        DelayQueue queue = new DelayQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">        Delayed element1 = new DelayedElement();</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.put(element1);</span><br><span class=\"line\"></span><br><span class=\"line\">        Delayed element2 = queue.take();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><blockquote>\n<ul>\n<li>LinkedBlockingQueue类实现了BlockingQueue接口  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();</span><br><span class=\"line\">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);</span><br><span class=\"line\">bounded.put(&quot;Value&quot;);</span><br><span class=\"line\">String value = bounded.take();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h2><blockquote>\n<ul>\n<li>PriorityBlockingQueue  </li>\n<li>PriorityBlockingQueue存储的对象必须是实现Comparable接口的 因为PriorityBlockingQueue队列会根据内部存储的每一个元素的compareTo方法比较每个元素的大小,这样在take出来的时候会根据优先级 将优先级最小的最先取出。  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static PriorityBlockingQueue&lt;User&gt; queue = new PriorityBlockingQueue&lt;User&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    queue.add(new User(1,&quot;wu&quot;));</span><br><span class=\"line\">    queue.add(new User(5,&quot;wu5&quot;));</span><br><span class=\"line\">    queue.add(new User(23,&quot;wu23&quot;));</span><br><span class=\"line\">    queue.add(new User(55,&quot;wu55&quot;));</span><br><span class=\"line\">    queue.add(new User(9,&quot;wu9&quot;));</span><br><span class=\"line\">    queue.add(new User(3,&quot;wu3&quot;));</span><br><span class=\"line\">    for (User user : queue) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(queue.take().name);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">static class User implements Comparable&lt;User&gt;&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public User(int age,String name) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(User o) &#123;</span><br><span class=\"line\">        return this.age &gt; o.age ? -1 : 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h2><blockquote>\n<ul>\n<li>SynchronousQueue实现BlockingQueue接口</li>\n<li>SynchronousQueue是一个内部只能包含单个元素的队列。将元素插入队列的线程被阻塞，直到另一个线程从队列中获取该元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</li>\n</ul>\n</blockquote>\n<h2 id=\"BlockingDeque接口\"><a href=\"#BlockingDeque接口\" class=\"headerlink\" title=\"BlockingDeque接口\"></a>BlockingDeque接口</h2><blockquote>\n<ul>\n<li>双端队列  </li>\n</ul>\n<p><img src=\"cc4.PNG\" alt=\"图片\">  </p>\n<ul>\n<li><p>线程将生成元素并将它们插入队列的任一端。如果双端队列当前已满，则插入线程将被阻塞，直到删除线程将一个元素从双端队列中取出。如果deque当前为空，则将阻止删除线程，直到插入线程将元素插入到双端队列中。  </p>\n</li>\n<li><p>LinkedBlockingDeque类是BlockingDeque接口的具体实现  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"ConcurrentMap\"><a href=\"#ConcurrentMap\" class=\"headerlink\" title=\"ConcurrentMap\"></a>ConcurrentMap</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConcurrentMap concurrentMap = new ConcurrentHashMap（）;</span><br><span class=\"line\"></span><br><span class=\"line\">concurrentMap.put（“key”，“value”）;</span><br><span class=\"line\"></span><br><span class=\"line\">Object value = concurrentMap.get（“key”）;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>java.util.concurrent.ConcurrentMap接口表示一个 能够处理并发访问（put和gets）的Map  </li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"linux笔记","url":"http://yoursite.com/2018/11/01/linux笔记/","content":"<h1 id=\"Linux笔记\"><a href=\"#Linux笔记\" class=\"headerlink\" title=\"Linux笔记\"></a>Linux笔记</h1><h2 id=\"Vim的使用\"><a href=\"#Vim的使用\" class=\"headerlink\" title=\"Vim的使用\"></a>Vim的使用</h2><blockquote>\n<p><strong>vim -R file</strong><br>只读打开  </p>\n<hr>\n<p><strong>:qall</strong><br>退出所有打开的文件<br><strong>:q</strong><br>退出当前打开的文件<br><strong>:wq</strong><br>写入文件并退出<br><strong>:q!</strong><br>强制退出<br><strong>:wq!</strong><br>强制写入文件并退出  </p>\n<hr>\n<p><strong>i</strong> 在当前光标位置前插入<br><strong>I</strong> 在当前行首插入 <strong>(键盘按shift与i键即可)</strong><br><strong>a</strong> 在当前光标位置后插入<br><strong>A</strong> 在当前行尾插入<br><strong>o</strong> 在当前行之后插入一行<br><strong>O</strong> 在当前行之前插入一行  </p>\n<hr>\n<p><strong>h</strong> 左移一个字符<br><strong>l</strong> 右移一个字符<br><strong>k</strong> 上移一个字符<br><strong>j</strong> 下移一个字符  </p>\n<hr>\n<p><strong>dd</strong> 删除当前行<br><strong>10dd</strong> 删除当前行开始的共10行<br><strong>D</strong> 删除当前字符至行尾<br><strong>dj</strong> 删除当前行和上一行<br><strong>dk</strong> 删除当前行和下一行  </p>\n<hr>\n<p><strong>gg</strong> 跳转到文件头<br><strong>G</strong> 跳转到文件尾 <strong>(键盘按shift与g键即可)</strong><br><strong>gg=G</strong>代码自动缩进<br><strong>$</strong> 跳转到行尾 <strong>(键盘按shift与4键即可)</strong><br><strong>0</strong> 跳转到行首<br><strong>冒号+行号</strong>，跳转到指定行；比如:120，跳转到120行<br><strong>Ctrl + d</strong> 向下滚动半屏<br><strong>Ctrl + u</strong> 向上滚动半屏<br><strong>Ctrl + f</strong> 向下滚动一屏<br><strong>Ctrl + b</strong> 向上滚动一屏  </p>\n<hr>\n<p><strong>u</strong> 撤销<br><strong>Ctrl + r</strong> 重做<br><strong>yy</strong> 复制当前行<br><strong>p</strong> 粘贴在当前位置<br><strong>v（逐字）或V（逐行）</strong> 进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制任意部分<br><strong>Ctrl + v</strong> 按块选择复制  </p>\n<hr>\n<p><strong>/text</strong> 查找text，按n健查找下一个，按N健查找前一个<br><strong>?text</strong> 查找text，反向查找，按n健查找下一个，按N健查找前一个  </p>\n<hr>\n<p><strong>:s/old/new/</strong> 用old替换new，替换当前行的第一个匹配<br><strong>:s/old/new/g</strong> 用old替换new，替换当前行的所有匹配<br><strong>:%s/old/new/</strong> 用old替换new，替换所有行的第一个匹配<br><strong>:%s/old/new/g</strong> 用old替换new，替换整个文件的所有匹配  </p>\n<hr>\n<p><strong>vim file1 file2</strong> 打开多个文件<br>:n 切换到下一个文件 :N切换到上一个文件<br><strong>:sp file3</strong> 在当前窗口打开新文件,水平分割屏幕<br><strong>:vsp file3</strong> 在当前窗口打开新文件,纵向分割屏幕<br><strong>ctrl+两次按w或者ctrl+w然后按上下键在上下窗口间切换</strong><br><strong>:only</strong> 关闭除当前分屏外的其他分屏<br><strong>:qa</strong> 关闭所有分屏</p>\n<hr>\n</blockquote>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><blockquote>\n<p><strong>后台运行</strong>  </p>\n<ul>\n<li><p>在命令后面加上 <strong>&amp;</strong> 实现后台运行，例如：sh test.sh &amp;<br><em>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行</em>  </p>\n</li>\n<li><p><strong>nohup command &amp;</strong><br>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：<br><strong>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</strong><br><em>在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行</em>  </p>\n</li>\n<li><p><strong>netstat -nap</strong><br>查看端口常用与对应的进程id  </p>\n</li>\n<li><p><strong>ls -l |grep “^-“|wc -l</strong><br>查看当前文件夹下的文件数  </p>\n</li>\n<li><p><strong>ls -l| awk ‘{ print “rm -f “,$9}’|sh</strong><br>大批量删除当前文件夹下的文件  </p>\n</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java基础笔记","url":"http://yoursite.com/2018/11/01/java基础笔记/","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a><strong>命名规范</strong></h2><blockquote>\n<ul>\n<li><p><strong>类名</strong>：使用UpperCamelCase风格（首字母都大写），必须遵从驼峰形式。 例如： ZipUtil  </p>\n</li>\n<li><p><strong>方法名、参数名、成员变量、局部变量：</strong> 都统一使用 lowerCamelCase 风格（第一个单词首字母小写，其他单词首字母大写），必须遵从驼峰形式。 例如： myName  </p>\n</li>\n<li><strong>静态变量、常量：</strong> 全部大写，单词间用下划线隔开，力求语义表达完整清楚。 例如：MAX_NAME_LENGTH</li>\n</ul>\n</blockquote>\n<h2 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a><strong>类型提升</strong></h2><blockquote>\n<ul>\n<li>整数值默认就是int类型，只有在数值常量后面加“L”或“l”才表明该常量是long型  </li>\n<li>浮点数默认是double类型，只有在数值后面加上“f”或“F”才表明该常量是float类型  </li>\n</ul>\n<p>Java语言支持的8中基本数据类型:  </p>\n<ul>\n<li>byte  </li>\n<li>short  </li>\n<li>int  </li>\n<li>long  </li>\n<li>float  </li>\n<li>double  </li>\n<li>boolean  </li>\n<li>char  </li>\n</ul>\n<p><em>String不是基本数据类型</em>  </p>\n<p><strong>类型提升规则</strong>  </p>\n<ul>\n<li>byte、short和char类型的值都被提升为int类型  </li>\n<li>如果有一个操作数是long类型，就将整个表达式提升为long类型  </li>\n<li>如果有一个操作数是float类型，就将整个表达式提升为float类型  </li>\n<li>如果任何一个操作数为double类型，结果将为double类型  </li>\n</ul>\n<p>short s1 = 1;<br>s1 = s1 + 1;  </p>\n<ul>\n<li>s1+1运算中的操作数s1会被自动提升为int类型，s1+1运算结果会成为int类型，再赋值给short类型的s1时，编译器会报告需要强制转换类型的错误  </li>\n</ul>\n<p>short s1 = 1;<br>s1 += 1;  </p>\n<ul>\n<li>+=是java语言中的运算符，Java编译器会对它特殊处理进行正确的编译  </li>\n</ul>\n</blockquote>\n<h2 id=\"equals与hashcode\"><a href=\"#equals与hashcode\" class=\"headerlink\" title=\"equals与hashcode\"></a><strong>equals与hashcode</strong></h2><blockquote>\n<ul>\n<li>equals方法用于比较两个对象是否相等，比较的是对象的值(==比较的是对象引用)  </li>\n<li>hashcode方法为对象生成唯一的哈希码  </li>\n</ul>\n<p><em>hashcode的作用是当对象放入HashTable，HashSet,HashMap等散列存储结构中时，为对象提供哈希码，指定对象的存储位置</em>  </p>\n<p>若重写了equals(Object obj)方法，则必要重写hashCode()方法  </p>\n<p>一般一个类的对象如果会存储在HashTable，HashSet,HashMap等散列存储结构中，那么重写equals后需要也重写hashCode，否则会导致存储数据的不唯一性（存储了两个equals相等的数据）<br><strong>对象放入散列集合的流程图</strong><br><img src=\"hash.gif\" alt=\"图片\">  </p>\n<ul>\n<li><p>hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用  </p>\n</li>\n<li><p>equals和hashCode需要同时覆盖  </p>\n</li>\n<li><p>若两个对象equals返回true，则hashCode有必要也返回相同的int数  </p>\n</li>\n<li><p>若两个对象equals返回false，则hashCode不一定返回不同的int数,但为不相等的对象生成不同hashCode值可以提高哈希表的性能  </p>\n</li>\n<li><p>若两个对象hashCode返回相同int数，则equals不一定返回true  </p>\n</li>\n<li><p>若两个对象hashCode返回不同int数，则equals一定返回false  </p>\n</li>\n<li><p>同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a><strong>泛型</strong></h2><blockquote>\n<p>泛型：JDK5引入了泛型机制，泛型实现了参数化类型的概念，使代码可以应用于多种类型；由编译器来保证类型的正确性。  </p>\n<p><em>基本类型无法作为泛型中的类型参数</em><br><strong>泛型的优点:</strong>  </p>\n<ul>\n<li>类型安全；泛型的主要目标是提高 Java 程序的类型安全  </li>\n<li>消除强制类型转换；消除源代码中的许多强制类型转换  </li>\n<li>潜在的性能收益  </li>\n</ul>\n<p><strong>类型参数命令约定</strong>  </p>\n<ul>\n<li>K —-键，比如映射的键  </li>\n<li>V —-值，比如 List 和 Set 的内容，或者 Map 中的值  </li>\n<li>E —-异常类  </li>\n<li>T —-泛型  </li>\n</ul>\n</blockquote>\n<h2 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a><strong>类型擦除</strong></h2><blockquote>\n<p>Java 泛型是使用擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。ArrayList<string> 和 ArrayList<integer> 在运行时，JVM 将它们视为同一类型  </integer></string></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ErasedTypeEquivalence &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class=\"line\">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class=\"line\">        System.out.println(c1 == c2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>输出结果是 true  </p>\n</blockquote>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a><strong>序列化</strong></h2><blockquote>\n<ul>\n<li>序列化：将对象转换为字节流  </li>\n<li>反序列化：将字节流转换为对象  </li>\n</ul>\n<p>Java通过对象输入输出流来实现序列化和反序列化  </p>\n<ul>\n<li>java.io.ObjectOutputStream 类的 writeObject() 方法可以实现序列化  </li>\n<li>java.io.ObjectInputStream 类的 readObject() 方法用于实现反序列化  </li>\n</ul>\n<p><em>被序列化的类必须属于 Enum、Array 和 Serializable类型其中的任何一种</em>  </p>\n<p><strong>1.serialVersionUID</strong><br>serialVersionUID 是Java为每个序列化类产生的版本标识<br>serialVersionUID 字段必须是static final long类型  </p>\n<p><strong>2.默认序列化机制</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;如果仅仅只是让某个类实现 Serializable接口，而没有其它任何处理的话，那么就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对其父类的字段以及该对象引用的其它对象也进行序列化。同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。<br><em>这里的父类和引用对象既然要进行序列化，那么它们当然也要满足序列化要求</em>  </p>\n<p><strong>3.非默认序列化机制</strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SerializeDemo02 &#123;</span><br><span class=\"line\">    static class Person implements Serializable &#123;</span><br><span class=\"line\">        transient private Integer age = null;</span><br><span class=\"line\">        // 其他内容</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 其他内容</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>当某个字段被声明为 transient 后，默认序列化机制就会忽略该字段,不会对其序列化  </p>\n<p><img src=\"xlh.png\" alt=\"图片\">  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java-nio笔记","url":"http://yoursite.com/2018/11/01/java-nio笔记/","content":"<h1 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h1><blockquote>\n<ul>\n<li><p>Java NIO(New IO)是一个可以替代标准Java IO API（从Java 1.4开始)，提供了与标准IO不同的IO工作方式  </p>\n</li>\n<li><p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中  </p>\n</li>\n<li><p>Java NIO可以让你非阻塞的使用IO  </p>\n</li>\n<li><p>Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"核心部分\"><a href=\"#核心部分\" class=\"headerlink\" title=\"核心部分\"></a>核心部分</h2><blockquote>\n<ul>\n<li>channels（通道）  </li>\n<li>Buffers（缓冲区）  </li>\n<li>Selectors（选择器）  </li>\n</ul>\n</blockquote>\n<h2 id=\"IO过程\"><a href=\"#IO过程\" class=\"headerlink\" title=\"IO过程\"></a>IO过程</h2><blockquote>\n<p>进程使用read( )系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过DMA完成，无需主CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read( )调用时指定的缓冲区  </p>\n<p>当进程请求I/O操作的时候，它执行一个系统调用（有时称为陷阱）将控制权移交给内核。C/C++程序员所熟知的底层方法open( )、read( )、write( )和close( )要做的无非就是建立和执行适当的系统调用。当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则进程被挂起，内核着手把数据读进内存<br><img src=\"nio1.PNG\" alt=\"图片\">  </p>\n<p><img src=\"nio2.PNG\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h2><blockquote>\n<h3 id=\"1-阻塞IO模型\"><a href=\"#1-阻塞IO模型\" class=\"headerlink\" title=\"1.阻塞IO模型\"></a>1.阻塞IO模型</h3><ul>\n<li><p>传统的一种IO模型，即在读写数据过程中会发生阻塞现象  </p>\n</li>\n<li><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = socket.read();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>如果数据没有就绪，就会一直阻塞在read方法  </p>\n<h3 id=\"2-非阻塞IO模型\"><a href=\"#2-非阻塞IO模型\" class=\"headerlink\" title=\"2.非阻塞IO模型\"></a>2.非阻塞IO模型</h3><ul>\n<li><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果  </p>\n</li>\n<li><p>如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回  </p>\n</li>\n<li><p>在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(true)&#123;</span><br><span class=\"line\">    data = socket.read();</span><br><span class=\"line\">    if(data!= error)&#123;</span><br><span class=\"line\">        处理数据</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h3 id=\"3-多路复用IO模型\"><a href=\"#3-多路复用IO模型\" class=\"headerlink\" title=\"3.多路复用IO模型\"></a>3.多路复用IO模型</h3><ul>\n<li><p><strong>Java NIO是多路复用IO模型</strong>  </p>\n</li>\n<li><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用  </p>\n</li>\n<li><p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞  </p>\n</li>\n<li><p>多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询  </p>\n<h3 id=\"4-信号驱动IO模型\"><a href=\"#4-信号驱动IO模型\" class=\"headerlink\" title=\"4.信号驱动IO模型\"></a>4.信号驱动IO模型</h3></li>\n<li>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作  <h3 id=\"5-异步IO模型\"><a href=\"#5-异步IO模型\" class=\"headerlink\" title=\"5.异步IO模型\"></a>5.异步IO模型</h3></li>\n<li><p>异步IO模型是最理想的IO模型  </p>\n</li>\n<li><p>在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事  </p>\n</li>\n<li><p>从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了  </p>\n</li>\n<li><p>用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作  </p>\n</li>\n</ul>\n<p><img src=\"vhHX.png\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"channels\"><a href=\"#channels\" class=\"headerlink\" title=\"channels\"></a>channels</h2><blockquote>\n<p><img src=\"javanio-channel-buffer.png\" alt=\"图片\"><br>NIO的所有IO都是从一个通道开始的。通道和流(Stream)有点类似，数据可以 从通道读出到缓冲区中，也可以从缓冲区写入到通道中<br>主要channels:  </p>\n<ul>\n<li>FileChanel  </li>\n<li>DatagramChannel  </li>\n<li>SocketChannel  </li>\n<li>ServerSocketChannel<br>Java NIO实现涵盖了UDP+TCP网络IO，以及文件IO  </li>\n</ul>\n<p>使用FileChanel demo：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile aFile = RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class=\"line\">FileChannel inChannel = aFile.getChannel();</span><br><span class=\"line\">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class=\"line\">int bytesRead = inChannel.read(buf);</span><br><span class=\"line\">while (bytesRead != -1) &#123;</span><br><span class=\"line\">    System.out.println(&quot;\\n=====Read &quot; + bytesRead);</span><br><span class=\"line\">    buf.flip();</span><br><span class=\"line\">    while(buf.hasRemaining())&#123;</span><br><span class=\"line\">        System.out.print((char) buf.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf.clear();</span><br><span class=\"line\">    bytesRead = inChannel.read(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aFile.close();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>buf.flip()调用。首先将数据读到缓冲区中，然后切换缓冲区为读模式，接着从缓冲区读数据</p>\n</blockquote>\n<h2 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h2><blockquote>\n<p>在Java NIO中核心缓冲区的实现类如下：</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>DoubleBuffer</li>\n<li>FloatBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>ShortBuffer</li>\n</ul>\n<p>这些缓冲区涵盖了可以通过NIO发送的基本数据类型：byte、<br>short、int、long、float、double、char。Java NIO中还有一个MappedByteBuffer实现，用来连接内存映射文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class=\"line\">FileChannel inChannel = aFile.getChannel();</span><br><span class=\"line\">//创建一个容量为48字节的缓冲区</span><br><span class=\"line\">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class=\"line\">int bytesRead = inChannel.read(buf); //write：从通道中读出数据到缓冲区</span><br><span class=\"line\">while (bytesRead != -1) &#123;</span><br><span class=\"line\">    buf.flip();  //flip: 将缓冲区切换到读模式</span><br><span class=\"line\">    while(buf.hasRemaining())&#123;</span><br><span class=\"line\">      System.out.print((char) buf.get()); // read: 一次读取一字节</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf.clear(); //clear: 清空缓冲区，准备下次读入</span><br><span class=\"line\">    bytesRead = inChannel.read(buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aFile.close();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<h3 id=\"缓冲区重要属性\"><a href=\"#缓冲区重要属性\" class=\"headerlink\" title=\"缓冲区重要属性\"></a>缓冲区重要属性</h3><p>position和limit具体含义取决于缓冲区是在读模式还是写模式  </p>\n<ul>\n<li><p>容量：capacity<br>缓冲区中最多写入capacity这么多的byte，long，char类型的数据。一旦满了，就需要先清空（已读数据，或者全部清空）才能再往里面写入数据  </p>\n</li>\n<li><p>位置：position<br>当往缓冲期里写数据时，总是会从某个位置(position)开始。刚开始时，position是0。当写入一个byte或者long类型的数据后，position会指向下一个可写入的位置。显然，postion的最大值等于capacity-1。当从缓冲区中读取数据时，也总是会从某个位置开始。当缓冲区从写模式切换到读模式后，postion会被重置为0。当从缓冲区中读取数据时，postion会指向下一个可读取的位置。  </p>\n</li>\n<li><p>上限：limit<br>缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数<br>在写模式下，缓冲区的limit指的是可以往缓冲区里写入多少数据。即，写模式下limit和capacity的含义相同<br>在读模式下，limit指的是可以从缓冲区中读出多少数据。因此，当缓冲区切换到读模式后，limit会设置为写模式时position的值  </p>\n</li>\n</ul>\n<h3 id=\"申请缓冲区空间\"><a href=\"#申请缓冲区空间\" class=\"headerlink\" title=\"申请缓冲区空间\"></a>申请缓冲区空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//申请大小为 48字节 的ByteBuffer</span><br><span class=\"line\">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class=\"line\"></span><br><span class=\"line\">//申请大小为 1024个字符 </span><br><span class=\"line\">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flip()   //将缓冲区从写模式切换为读模式，也就是将limit设置为position，然后重置position为0</span><br><span class=\"line\"></span><br><span class=\"line\">channel.write(buf)  //从缓冲区中读取数据写入到通道中</span><br><span class=\"line\"></span><br><span class=\"line\">buf.get()   //从缓冲区中读取数据</span><br><span class=\"line\"></span><br><span class=\"line\">rewind()   //将position重置为0，重复读取缓冲区中的所有数据。而limit值不变，仍然表示缓冲区中可以读出多少个元素（字节、字符等等）</span><br><span class=\"line\"></span><br><span class=\"line\">clear()  //清空所有数据并重置position等属性  </span><br><span class=\"line\"></span><br><span class=\"line\">compact()  //会将所有未读数据复制到缓冲区开头，然后会将position设置为最后一个未读数据之后。而limit仍然会设置为capacity，就和clear()方法中的一样。现在，就可以继续往缓冲期写入而不会覆盖未读数据</span><br><span class=\"line\"></span><br><span class=\"line\">mark() 和 reset()  //通过调用mark()方法，可以在缓冲区中的指定位置做打个标签，随后可以通过调用reset()方法将缓冲区的position重置到打标签的位置</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<h2 id=\"Selectors\"><a href=\"#Selectors\" class=\"headerlink\" title=\"Selectors\"></a>Selectors</h2><blockquote>\n<p><img src=\"javanio-selecor-3-channel.png\" alt=\"图片\"><br>选择器可以让一个线程处理多个通道。当应用程序打开多个连接（Channel），需要先将Channel注册到选择器中，之后就可以调用它的select()方法。该方法一直阻塞到所注册通道中某个事件就绪为止。一旦方法返回，线程就可以处理这些事件。这些事件包括有连接进来，数据接收等  </p>\n<h3 id=\"创建选择器\"><a href=\"#创建选择器\" class=\"headerlink\" title=\"创建选择器\"></a><strong>创建选择器</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"将通道注册到选择器中\"><a href=\"#将通道注册到选择器中\" class=\"headerlink\" title=\"将通道注册到选择器中\"></a><strong>将通道注册到选择器中</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.configureBlocking(false);</span><br><span class=\"line\">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>通道只有在非阻塞模式下才能使用选择器。这就意味着FileChannel是不能使用选择器的，原因是FileChannel是无法切换到非阻塞模式下的，而基于Socket的通道是可以的  </p>\n<h3 id=\"SelectionKey\"><a href=\"#SelectionKey\" class=\"headerlink\" title=\"SelectionKey\"></a><strong>SelectionKey</strong></h3><p>register()方法的第二个参数。这是一个所谓的兴趣集合（interest set），意思是选择器对通道中的哪些事件感兴趣，以监听这类事件,可以监听的事件类型有四种：  </p>\n<ul>\n<li>SelectionKey.OP_CONNECT  </li>\n<li>SelectionKey.OP_ACCEPT  </li>\n<li>SelectionKey.OP_READ  </li>\n<li>SelectionKey.OP_WRITE  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>在将通道注册到选择器时，调用了register()方法，返回值为SelectionKey对象。SelectionKey对象包含了几个有意思的属性：  </p>\n<ul>\n<li>兴趣集合（interest set）  </li>\n<li>就绪状态集合（ready set） </li>\n<li>通道 </li>\n<li>选择器  </li>\n<li>附加对象 (可选)  <h3 id=\"兴趣集合（interest-set）\"><a href=\"#兴趣集合（interest-set）\" class=\"headerlink\" title=\"兴趣集合（interest set）\"></a><strong>兴趣集合（interest set）</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int interestSet = selectionKey.interestOps();</span><br><span class=\"line\">boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class=\"line\">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class=\"line\">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class=\"line\">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>可以使用AND（与）操作来判断给定的集合中是否包含了某个事件  </p>\n<h3 id=\"就绪状态集合（ready-set）\"><a href=\"#就绪状态集合（ready-set）\" class=\"headerlink\" title=\"就绪状态集合（ready set）\"></a><strong>就绪状态集合（ready set）</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selectionKey.isAcceptable();</span><br><span class=\"line\">selectionKey.isConnectable();</span><br><span class=\"line\">selectionKey.isReadable();</span><br><span class=\"line\">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>就绪状态集合（ready set），顾名思义，就是指通道中已经就绪的操作集合。在做出『选择』之后，主要就是对就绪状态集合进行操作  </p>\n<h3 id=\"从selectionKey获取事件发生的对应通道\"><a href=\"#从selectionKey获取事件发生的对应通道\" class=\"headerlink\" title=\"从selectionKey获取事件发生的对应通道\"></a><strong>从selectionKey获取事件发生的对应通道</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel  channel  = selectionKey.channel();</span><br><span class=\"line\">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>访问SelectionKey中的通道和选择器很简单  </p>\n<h3 id=\"附加对象\"><a href=\"#附加对象\" class=\"headerlink\" title=\"附加对象\"></a><strong>附加对象</strong></h3><p>可以在SelectionKey中附加一个对象，以便于识别给定通道，或者为通道附加更多信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selectionKey.attach(theObject);</span><br><span class=\"line\">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<h3 id=\"channel事件发生获取\"><a href=\"#channel事件发生获取\" class=\"headerlink\" title=\"channel事件发生获取\"></a><strong>channel事件发生获取</strong></h3><p>一旦在选择器中注册了一个或者几个通道之后，就可以调用select()方法。这些方法会返回你感兴趣的事件已经就绪状态的通道，比如Connect，Accept，Read 或者 Write。换言之，如果想选择可以读取数据的通道，select()方法会返回那些Read就绪的通道。select()方法有下面几种重载模式：  </p>\n<ul>\n<li><p>int select() - 会被阻塞到所注册的事件就绪为止  </p>\n</li>\n<li><p>int select(long timeout) - 也会阻塞，但是可以设置阻塞超时时间（参数timeout）  </p>\n</li>\n<li><p>int selectNow() - 不会阻塞，会立即返回任何就绪的通道  </p>\n</li>\n</ul>\n<p>int类型的返回值表示有多少个通道已经就绪，即，在最后一次调用select()方法后有多少通道已经就绪。假如调用了一次select()方法，返回了1，说明有一个通道已经就绪；此时再调用一次select()方法，又有一个Channel也变成就绪状态，则还是会返回1。如果不对第一次已经就绪的那个通道做任何处理的话，这时应该有两个通道是处于就绪状态的。但是在每次调用select()方法时，只会有一个通道变为就绪状态。  </p>\n<p>在调用select()方法后，其返回值说明有几个通道已经就绪，这时可以调用selectedKeys()方法，通过『已选择键集合』来访问这些通道，像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>遍历『已选择键集合』就可以访问已经就绪的各个通道:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\">while(keyIterator.hasNext()) &#123;</span><br><span class=\"line\">    SelectionKey key = keyIterator.next();</span><br><span class=\"line\">    if(key.isAcceptable()) &#123;</span><br><span class=\"line\">        // ServerSocketChannel可以接受连接</span><br><span class=\"line\">    &#125; else if (key.isConnectable()) &#123;</span><br><span class=\"line\">        // 已经连接到远程服务器</span><br><span class=\"line\">    &#125; else if (key.isReadable()) &#123;</span><br><span class=\"line\">        // 通道可以读取</span><br><span class=\"line\">    &#125; else if (key.isWritable()) &#123;</span><br><span class=\"line\">        // 通道可以写入</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keyIterator.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>注意到在最后调用了keyIterator.remove()方法，在通道处理完成之后必须这样做的原因是选择器不会自己从已选择键集合中去掉SelectionKey实例。当下次通道就绪时，选择器会将它再次加入到已选择就绪集合中<br>SelectionKey.channel()返回的通道实例需要强制转换成要处理的通道类型，比如ServerSocketChannel或者SocketChannel等  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br><span class=\"line\">channel.configureBlocking(false);</span><br><span class=\"line\">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">while(true) &#123;</span><br><span class=\"line\">  int readyChannels = selector.select();</span><br><span class=\"line\">  if(readyChannels == 0) continue;</span><br><span class=\"line\">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\">  while(keyIterator.hasNext()) &#123;</span><br><span class=\"line\">    SelectionKey key = keyIterator.next();</span><br><span class=\"line\">    if(key.isAcceptable()) &#123;</span><br><span class=\"line\">        // ServerSocketChannel可以接受连接</span><br><span class=\"line\">    &#125; else if (key.isConnectable()) &#123;</span><br><span class=\"line\">        // 已经连接到远程服务器</span><br><span class=\"line\">    &#125; else if (key.isReadable()) &#123;</span><br><span class=\"line\">        // 通道可以读取</span><br><span class=\"line\">    &#125; else if (key.isWritable()) &#123;</span><br><span class=\"line\">        // 通道可以写入</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keyIterator.remove();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"非阻塞Server实现\"><a href=\"#非阻塞Server实现\" class=\"headerlink\" title=\"非阻塞Server实现\"></a>非阻塞Server实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Selector selector = Selector.open();</span><br><span class=\"line\">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class=\"line\">    channel.configureBlocking(false);</span><br><span class=\"line\">    channel.socket().bind(new InetSocketAddress(port), 1024);</span><br><span class=\"line\">    channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    System.out.println(&quot;time server is run&quot;);</span><br><span class=\"line\">    while(true)&#123;</span><br><span class=\"line\">\t    selector.select();</span><br><span class=\"line\">\t    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">\t    Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class=\"line\">\t    SelectionKey key = null;</span><br><span class=\"line\">\t    while(iterator.hasNext())&#123;</span><br><span class=\"line\">\t\t    key = iterator.next();</span><br><span class=\"line\">\t\t    iterator.remove();</span><br><span class=\"line\">\t\t    try&#123;</span><br><span class=\"line\">\t\t\t    handleInput(key);</span><br><span class=\"line\">\t\t    &#125;catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t    if (key != null) &#123;</span><br><span class=\"line\">\t\t\t\t    key.cancel();</span><br><span class=\"line\">\t\t\t\t    if (key.channel() != null)</span><br><span class=\"line\">\t\t\t\t    key.channel().close();</span><br><span class=\"line\">\t\t\t    &#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">        if(selector!=null)&#123;</span><br><span class=\"line\">\t        try &#123;</span><br><span class=\"line\">\t\t        selector.close();</span><br><span class=\"line\">\t        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t        e.printStackTrace();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void handleInput(SelectionKey key) throws IOException&#123;</span><br><span class=\"line\">\tif(key.isValid())&#123;</span><br><span class=\"line\">\t\tif(key.isAcceptable())&#123;</span><br><span class=\"line\">\t\t\tServerSocketChannel schannel = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">\t\t\tSocketChannel accept = schannel.accept();</span><br><span class=\"line\">\t\t\taccept.configureBlocking(false);</span><br><span class=\"line\">\t\t\taccept.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(key.isReadable())&#123;</span><br><span class=\"line\">\t\t\tSocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">\t\t\tByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class=\"line\">\t\t\tint size = sc.read(buffer);  //非阻塞，数据已在内核空间准备好</span><br><span class=\"line\">\t\t\tif(size&gt;0)&#123;</span><br><span class=\"line\">\t\t\t\tbuffer.flip();</span><br><span class=\"line\">\t\t\t\tbyte[] arr = new byte[buffer.remaining()];</span><br><span class=\"line\">\t\t\t\tbuffer.get(arr);</span><br><span class=\"line\">\t\t\t\tString body = new String(arr,&quot;UTF-8&quot;);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(body);</span><br><span class=\"line\">\t\t\t\tSimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class=\"line\">\t\t\t\tbyte[] bytes = res.getBytes();</span><br><span class=\"line\">\t\t\t    ByteBuffer buffe = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">\t\t\t    buffe.put(bytes);</span><br><span class=\"line\">\t\t\t    buffe.flip();</span><br><span class=\"line\">\t\t\t    sc.write(buffe);</span><br><span class=\"line\">\t\t\t&#125;else if(size&lt;0)&#123;</span><br><span class=\"line\">\t\t\t\tkey.cancel();</span><br><span class=\"line\">\t\t\t\tsc.close();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[],"tags":[]},{"title":"interview笔记","url":"http://yoursite.com/2018/11/01/interview笔记/","content":"<h1 id=\"Interview\"><a href=\"#Interview\" class=\"headerlink\" title=\"Interview\"></a>Interview</h1><h1 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h1><blockquote>\n<ul>\n<li><p>试用期<br><em>试用期多久，工资比例</em>  </p>\n</li>\n<li><p>收入<br><em>薪资多少，扣税比例是多少，每年的涨薪机制是怎样的，是否有股票期权</em>  </p>\n</li>\n<li><p>福利<br><em>五险一金的缴纳比例和缴纳基数，年休假多少天，平时的补助和福利有哪些</em>  </p>\n</li>\n<li><p>工作强度<br><em>上下班时间、加班频率，加班是否有加班费或调休</em>  </p>\n</li>\n<li><p>融资计划<br><em>如果面试的是创业公司，特别是天使轮、A轮公司，一定要问一下“下一轮融资大概什么时候启动“</em>  </p>\n</li>\n<li><p>工作内容<br><em>确认工作内容是否与自身兴趣、技能相匹配</em></p>\n</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"springcloud笔记","url":"http://yoursite.com/2018/11/01/springcloud笔记/","content":"<h1 id=\"SpringCloud笔记\"><a href=\"#SpringCloud笔记\" class=\"headerlink\" title=\"SpringCloud笔记\"></a>SpringCloud笔记</h1><blockquote>\n<p>SpringCloud提供快速构建分布式系统中的常见模式工具  </p>\n<ul>\n<li>分布式/版本化配置  </li>\n<li>服务注册和发现  </li>\n<li>断路器  </li>\n<li>智能路由  </li>\n<li>负载均衡  </li>\n<li>微代理  </li>\n<li>service-to-service调用  </li>\n<li>分布式消息传递  </li>\n</ul>\n<p>SpringCloud可以快速地实现支持这些模式的服务和应用程序,并将在任何分布式环境中运行良好  </p>\n<ul>\n<li><a href=\"https://springcloud.cc/\" target=\"_blank\" rel=\"noopener\">学习资料</a>  </li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/70148833\" target=\"_blank\" rel=\"noopener\">demo例程</a>  </li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"springboot注解笔记","url":"http://yoursite.com/2018/11/01/springboot注解笔记/","content":"<h1 id=\"SpringBoot注解（siwang-hu-nbsp-nbsp-V1-0）\"><a href=\"#SpringBoot注解（siwang-hu-nbsp-nbsp-V1-0）\" class=\"headerlink\" title=\"SpringBoot注解（siwang.hu&nbsp;&nbsp;V1.0）\"></a>SpringBoot注解（siwang.hu&nbsp;&nbsp;V1.0）</h1><blockquote>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/reference/htmlsingle/\" target=\"_blank\" rel=\"noopener\">官方学习资料</a>  </p>\n</blockquote>\n<h2 id=\"1-nbsp-nbsp-SpringBootApplication\"><a href=\"#1-nbsp-nbsp-SpringBootApplication\" class=\"headerlink\" title=\"1.&nbsp;&nbsp;@SpringBootApplication\"></a><strong>1.&nbsp;&nbsp;@SpringBootApplication</strong></h2><blockquote>\n<ul>\n<li><p>注解在启动类上  </p>\n</li>\n<li><p>等效于以默认属性使用 @Configuration ， @EnableAutoConfiguration 和 @ComponentScan  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class StartApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String args[])throws Exception&#123;</span><br><span class=\"line\">        SpringApplication.run(StartApplication.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n</blockquote>\n<h2 id=\"2-nbsp-nbsp-value\"><a href=\"#2-nbsp-nbsp-value\" class=\"headerlink\" title=\"2.&nbsp;&nbsp;@value\"></a><strong>2.&nbsp;&nbsp;@value</strong></h2><blockquote>\n<ul>\n<li>该注解可以读取springboot中的配置文件中的参数值  </li>\n<li>方便读取自定义的配置参数  </li>\n</ul>\n<p>application.properties文件中的自定义配置如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port=8080</span><br><span class=\"line\">ip=127.0.0.1</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>使用方式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;port&#125;&quot;)</span><br><span class=\"line\">private int Port;</span><br><span class=\"line\"></span><br><span class=\"line\">@Value((&quot;$&#123;ip&#125;&quot;))</span><br><span class=\"line\">private String Ip;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"3-nbsp-nbsp-Configuration\"><a href=\"#3-nbsp-nbsp-Configuration\" class=\"headerlink\" title=\"3.&nbsp;&nbsp;@Configuration\"></a><strong>3.&nbsp;&nbsp;@Configuration</strong></h2><blockquote>\n<ul>\n<li><p>注解在类上,相当于用spring的时候xml里面的beans标签  </p>\n</li>\n<li><p>代表这个类是一个配置类  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"4-nbsp-nbsp-Bean\"><a href=\"#4-nbsp-nbsp-Bean\" class=\"headerlink\" title=\"4.&nbsp;&nbsp;@Bean\"></a><strong>4.&nbsp;&nbsp;@Bean</strong></h2><blockquote>\n<ul>\n<li><p>注解在方法上，产生bean的方法，并且交给Spring容器管理  </p>\n</li>\n<li><p>如果未通过@Bean指定bean的名称，则默认与标注的方法名相同  </p>\n</li>\n<li><p>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RedisCache extends CachingConfigurerSupport &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    RedisConnectionFactory redisConnectionFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RedisTemplate&lt;String,Object&gt; redisTemplate()&#123;</span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class=\"line\">        initDomainRedisTemplate(redisTemplate, redisConnectionFactory);</span><br><span class=\"line\">        return redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private void initDomainRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate, RedisConnectionFactory factory) &#123;</span><br><span class=\"line\">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class=\"line\">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class=\"line\">        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class=\"line\">        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());</span><br><span class=\"line\">        redisTemplate.setConnectionFactory(factory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;</span><br><span class=\"line\">        return redisTemplate.opsForHash();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;</span><br><span class=\"line\">        return redisTemplate.opsForValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"5-nbsp-nbsp-Autowired和-Resource\"><a href=\"#5-nbsp-nbsp-Autowired和-Resource\" class=\"headerlink\" title=\"5.&nbsp;&nbsp;@Autowired和@Resource\"></a><strong>5.&nbsp;&nbsp;@Autowired和@Resource</strong></h2><blockquote>\n<ul>\n<li><p>@Autowired与@Resource都可以用来装配bean  </p>\n</li>\n<li><p>可以写在字段上,或写在setter方法上  </p>\n</li>\n<li><p>@Autowired是默认按照类型装配的 @Resource默认是按照名称装配  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"6-nbsp-nbsp-Qualifier\"><a href=\"#6-nbsp-nbsp-Qualifier\" class=\"headerlink\" title=\"6.&nbsp;&nbsp;@Qualifier\"></a><strong>6.&nbsp;&nbsp;@Qualifier</strong></h2><blockquote>\n<ul>\n<li><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定  </p>\n</li>\n<li><p>@Qualifier限定描述符能进行更细粒度的控制如何选择候选者  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Autowired </span><br><span class=\"line\">@Qualifier(value = “userOpService”) </span><br><span class=\"line\">private UserService userOpService;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"7-nbsp-nbsp-ResponseBody\"><a href=\"#7-nbsp-nbsp-ResponseBody\" class=\"headerlink\" title=\"7.&nbsp;&nbsp;@ResponseBody\"></a><strong>7.&nbsp;&nbsp;@ResponseBody</strong></h2><blockquote>\n<ul>\n<li><p>注解在方法上，表明将结果直接写入HTTP response body，不做界面跳转  </p>\n</li>\n<li><p>比如获取json数据，加上@responsebody后，会直接返回json数据  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"8-nbsp-nbsp-RestController与-Controller\"><a href=\"#8-nbsp-nbsp-RestController与-Controller\" class=\"headerlink\" title=\"8.&nbsp;&nbsp;@RestController与@Controller\"></a><strong>8.&nbsp;&nbsp;@RestController与@Controller</strong></h2><blockquote>\n<ul>\n<li><p>@Controller一般用于前端界面跳转  </p>\n</li>\n<li><p>@RestController相当于@ResponseBody ＋ @Controller合在一起的作用  </p>\n</li>\n<li><p>@RestController用于开发restful api服务  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"9-nbsp-nbsp-RequestMapping\"><a href=\"#9-nbsp-nbsp-RequestMapping\" class=\"headerlink\" title=\"9.&nbsp;&nbsp;@RequestMapping\"></a><strong>9.&nbsp;&nbsp;@RequestMapping</strong></h2><blockquote>\n<ul>\n<li>对外Url链接地址<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value=&quot;/voice/add&quot;,method =&#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class=\"line\">public boolean addVoice(Voice voice) &#123;</span><br><span class=\"line\">    return voiceService.insertVoice(voice);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"10-nbsp-nbsp-组件注解\"><a href=\"#10-nbsp-nbsp-组件注解\" class=\"headerlink\" title=\"10.&nbsp;&nbsp;组件注解\"></a><strong>10.&nbsp;&nbsp;组件注解</strong></h2><blockquote>\n<ul>\n<li><p>@Component注解放在类的头上,是所有受Spring 管理组件的通用形式,不推荐使用  </p>\n</li>\n<li><p>@Service对应的是业务层Bean  </p>\n</li>\n<li><p>@Repository对应数据访问层Bean  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"11-nbsp-nbsp-Transactional\"><a href=\"#11-nbsp-nbsp-Transactional\" class=\"headerlink\" title=\"11.&nbsp;&nbsp;@Transactional\"></a><strong>11.&nbsp;&nbsp;@Transactional</strong></h2><blockquote>\n<ul>\n<li><p>事务注解，添加在方法或类上，声明为事务  </p>\n</li>\n<li><p>一般用于数据库操作函数中  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional</span><br><span class=\"line\">public boolean checkVoiceById(int id,Stringcommit)&#123;</span><br><span class=\"line\">    Voice voice=voiceDao.findById(id);</span><br><span class=\"line\">    voice.setCommit(commit);</span><br><span class=\"line\">    voiceDao.save(voice);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"12-nbsp-nbsp-Entity与-Table-name-”tb-voice”\"><a href=\"#12-nbsp-nbsp-Entity与-Table-name-”tb-voice”\" class=\"headerlink\" title=\"12.&nbsp;&nbsp;@Entity与@Table(name=”tb_voice”)\"></a><strong>12.&nbsp;&nbsp;@Entity与@Table(name=”tb_voice”)</strong></h2><blockquote>\n<ul>\n<li><p>@Entity声明持久化类  </p>\n</li>\n<li><p>@Table声明表名  </p>\n</li>\n<li><p>@Id声明表主键  </p>\n</li>\n<li><p>@GeneratedValue(strategy= GenerationType.IDENTITY)声明表主键自动增长  </p>\n</li>\n<li><p>@Column(nullable = false,name = “id”)声明表字段的属性和名称  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Entity</span><br><span class=\"line\">@Table(name=&quot;tb_voice&quot;)</span><br><span class=\"line\">public class Voice implements Serializable&#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 2300044412175011558L;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class=\"line\">    @Column(nullable = false,name = &quot;id&quot;)</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;name&quot;)</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;label&quot;)</span><br><span class=\"line\">    private String label;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;datetime&quot;)</span><br><span class=\"line\">    private Date datetime;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;uri&quot;)</span><br><span class=\"line\">    private String uri;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;commit&quot;)</span><br><span class=\"line\">    private String commit;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(nullable = false , name = &quot;size&quot;)</span><br><span class=\"line\">    private String size;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(int id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setLabel(String label) &#123;</span><br><span class=\"line\">        this.label = label;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDatetime(Date datetime) &#123;</span><br><span class=\"line\">        this.datetime = datetime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUri(String uri) &#123;</span><br><span class=\"line\">        this.uri = uri;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setCommit(String commit) &#123;</span><br><span class=\"line\">        this.commit = commit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSize(String size) &#123;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getId() &#123;</span><br><span class=\"line\">        return id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getLabel() &#123;</span><br><span class=\"line\">        return label;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date getDatetime() &#123;</span><br><span class=\"line\">        return datetime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getUri() &#123;</span><br><span class=\"line\">        return uri;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getCommit() &#123;</span><br><span class=\"line\">        return commit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getSize() &#123;</span><br><span class=\"line\">        return size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Voice&#123;&quot; +</span><br><span class=\"line\">                &quot;id=&quot; + id +</span><br><span class=\"line\">                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, label=&apos;&quot; + label + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, datetime=&quot; + datetime +</span><br><span class=\"line\">                &quot;, uri=&apos;&quot; + uri + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, commit=&apos;&quot; + commit + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, size=&apos;&quot; + size + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"13-nbsp-nbsp-Query\"><a href=\"#13-nbsp-nbsp-Query\" class=\"headerlink\" title=\"13.&nbsp;&nbsp;@Query\"></a><strong>13.&nbsp;&nbsp;@Query</strong></h2><blockquote>\n<ul>\n<li>用于springboot JPA中的自定义sql查询语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BookDao extends JpaRepository&lt;Book, Integer&gt;&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //Hql语句查询</span><br><span class=\"line\">    @Query(&quot;select b from Book b where b.bookName like %?1%&quot;)</span><br><span class=\"line\">    public List&lt;Book&gt; findByBookName(String bookName);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //本地sql语句查询</span><br><span class=\"line\">    @Query(value=&quot;select * from t_book order by RAND() limit ?1&quot;,nativeQuery=true)</span><br><span class=\"line\">    public List&lt;Book&gt; randomList(Integer n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"14-nbsp-nbsp-ControllerAdvice与-ExceptionHandler\"><a href=\"#14-nbsp-nbsp-ControllerAdvice与-ExceptionHandler\" class=\"headerlink\" title=\"14.&nbsp;&nbsp;@ControllerAdvice与@ExceptionHandler\"></a><strong>14.&nbsp;&nbsp;@ControllerAdvice与@ExceptionHandler</strong></h2><blockquote>\n<ul>\n<li><p>全局异常处理  </p>\n</li>\n<li><p>用于拦截服务器的异常  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ControllerAdvice</span><br><span class=\"line\">public class GlobalExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExceptionHandler(Exception.class)</span><br><span class=\"line\">    public String handleException()&#123;</span><br><span class=\"line\">        return &quot;Exception!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"nlp笔记","url":"http://yoursite.com/2018/11/01/nlp笔记/","content":"<h1 id=\"文本建模\"><a href=\"#文本建模\" class=\"headerlink\" title=\"文本建模\"></a>文本建模</h1><blockquote>\n<p><strong>1.向量空间模型</strong><br>向量空间模型(VSM)使用词袋模型(词袋模型基于一元文法统计模型)表示方法将词表示成one-hot向量，该模型假设文档之间是相互独立的，词语之间也是相互独立的将文本映射成高维的特征向量，利用特征空间向量来表示文本  </p>\n<p><strong>2.浅层语义分析模型</strong><br> 浅层语义分析模型(LSA),构造一个文档与词语的关系矩阵，矩阵的行表示词语，矩阵的列则表示文档，矩阵中元素的值表示该词语出现在该文档中的次数，也可以使用词语在文档中的权重来给矩阵中的元素赋值。使用PCA降维对文档与词语的关系矩阵进行降维，使得文档中相似的词合并掉  </p>\n<p><strong>3.文档主题模型</strong><br>文档主题模型(LDA)从语义出发，在词语和文档的关系之外，引入了主题词的概念，增加了词语和主题词的关系，主题词和文档的关系。该模型要指定文档主题的数量，即文本语料中包含有多少个主题，通过对文本语料的训练，给出每个文本属于每个主题的概率，以及文本中的每个词语属于每个主题的概率。  </p>\n</blockquote>\n<h1 id=\"词频分析\"><a href=\"#词频分析\" class=\"headerlink\" title=\"词频分析\"></a>词频分析</h1><blockquote>\n<p><strong>pip install nltk</strong><br><strong>pip install matplotlib</strong><br>(‘会议’, 6182)<br>(‘电话’, 4136)<br>(‘需求’, 2488)<br>(‘视频会议’, 2263)<br>(‘试用’, 2176)<br>(‘购买’, 2143)<br>(‘注册’, 2117)<br>(‘收费’, 1945)<br>(‘支持’, 1882)<br>(‘联系’, 1825)<br>(‘下载’, 1812)<br>(‘系统’, 1718)<br>(‘账号’, 1678)<br>(‘软件’, 1665)<br>(‘电话会议’, 1609)<br>(‘参加’, 1599)<br>(‘邮箱’, 1585)<br>(‘手机’, 1531)<br>(‘电脑’, 1415)<br>(‘视频’, 1378)<br>(‘测试’, 1349)<br>(‘销售’, 1187)<br>(‘接入’, 1074)<br>(‘报价’, 1021)<br>(‘呼叫’, 995)<br>(‘咨询’, 993)<br>(‘参会’, 939)<br>(‘终端’, 882)<br>(‘产品’, 846)<br>(‘负责人’, 834)<br>(‘网络’, 822)<br>(‘申请’, 796)<br>(‘帐号’, 785)<br>(‘登录’, 763)<br>(‘中心’, 741)<br>(‘方’, 738)<br>(‘链接’, 728)<br>(‘网页’, 713)<br>(‘人数’, 695)<br>(‘操作’, 690)<br>(‘问题’, 690)<br>(‘密码’, 690)<br>(‘会议室’, 686)<br>(‘硬件’, 644)<br>(‘官网’, 589)<br>(‘行业’, 560)<br>(‘免费’, 560)<br>(‘买’, 552)<br>(‘功能’, 551)<br>(‘点击’, 540)  </p>\n<p><img src=\"word.PNG\" alt=\"词频分布图\"><br><img src=\"ciyun.jpg\" alt=\"分布图\"></p>\n</blockquote>\n<h1 id=\"Word2Vec词向量训练\"><a href=\"#Word2Vec词向量训练\" class=\"headerlink\" title=\"Word2Vec词向量训练\"></a>Word2Vec词向量训练</h1><blockquote>\n<p> <strong>pip install gensim</strong><br>构建三层神经网络，分别是输入层，隐藏层,softmax输出层。对词进行one-hot编码，输入网络训练，词向量训练结果为词one-hot向量与网络隐藏层中间权重矩阵相乘<br><strong>1.skip-gram算法</strong><br><img src=\"skip-gram.png\" alt=\"算法图\">  </p>\n<p><strong>2.CBOW算法</strong><br><img src=\"CBOW.png\" alt=\"算法图\"><br><strong>“产品”的相似词</strong>(1,300)向量  </p>\n<p>平台 0.7766879796981812<br>业务 0.7454820275306702<br>解决方案 0.7286168336868286<br>服务 0.7222141027450562<br>软件 0.7052211761474609<br>方案 0.6947022676467896<br>系统 0.6891728639602661<br>功能 0.6855509281158447<br>智能 0.6630642414093018<br>代理 0.6596889495849609  </p>\n</blockquote>\n<h1 id=\"高频词聚类-意图分析\"><a href=\"#高频词聚类-意图分析\" class=\"headerlink\" title=\"高频词聚类(意图分析)\"></a>高频词聚类(意图分析)</h1><blockquote>\n<p><strong>pip install sckit-learn</strong><br><strong>k-means聚类算法</strong><br>第1类：  [‘手机’, ‘电脑’, ‘网页’]<br>第2类：  [‘买’, ‘购买’]<br>第3类：  [‘邮箱’]<br>第4类：  [‘会议’]<br>第5类：  [‘免费’, ‘问题’]<br>第6类：  [‘中心’, ‘电话会议’, ‘硬件’, ‘视频会议’]<br>第7类：  [‘需求’]<br>第8类：  [‘负责人’, ‘销售’]<br>第9类：  [‘官网’, ‘密码’, ‘点击’, ‘登录’, ‘链接’]<br>第10类：  [‘人数’]<br>第11类：  [‘电话’]<br>第12类：  [‘产品’, ‘功能’, ‘支持’, ‘系统’, ‘网络’, ‘视频’, ‘软件’]<br>第13类：  [‘联系’]<br>第14类：  [‘下载’, ‘操作’]<br>第15类：  [‘帐号’, ‘账号’]<br>第16类：  [‘测试’, ‘试用’]<br>第17类：  [‘接入’, ‘终端’]<br>第18类：  [‘行业’]<br>第19类：  [‘注册’, ‘申请’]<br>第20类：  [‘收费’]<br>第21类：  [‘参加’]<br>第22类：  [‘报价’]<br>第23类：  [‘会议室’, ‘参会’, ‘方’]<br>第24类：  [‘呼叫’]<br>第25类：  [‘咨询’]  </p>\n</blockquote>\n<h1 id=\"关联分析\"><a href=\"#关联分析\" class=\"headerlink\" title=\"关联分析\"></a>关联分析</h1><blockquote>\n<p><strong>pip install apyori</strong><br>关联分析发现隐藏在大型数据集中有意义的数据联系的方法  </p>\n<p>关联规则是形如X→Y的表达式，其中X和Y是不相交的项集，即X∩Y=∅。关联规则的强度可以用支持度和置信度衡量。支持度确定规则可以用于给定数据集的频繁程度，而置信度确定Y在包含X的事务中出现的频繁程度。支持度(s)和置信度(c)的形式定义如下：<br><img src=\"6261.PNG\" alt=\"定义\"><br><img src=\"6262.PNG\" alt=\"公式\"><br><strong>Apriori算法</strong>&nbsp;&nbsp; <a href=\"https://blog.csdn.net/qq_23100787/article/details/51790637\" target=\"_blank\" rel=\"noopener\">FP增长算法</a><br><a href=\"http://crescentmoon.info/2013/02/18/%E3%80%8A%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA%E3%80%8B%E6%80%BB%E7%BB%93%E4%B9%8B%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">参考资料</a>  </p>\n</blockquote>\n<h1 id=\"关键词提取\"><a href=\"#关键词提取\" class=\"headerlink\" title=\"关键词提取\"></a>关键词提取</h1><blockquote>\n<p><strong>pip install jieba</strong></p>\n<h2 id=\"TF-IDF算法\"><a href=\"#TF-IDF算法\" class=\"headerlink\" title=\"TF-IDF算法\"></a><strong>TF-IDF</strong>算法</h2><p><strong>关键字的提取严重依赖预料库</strong><br>TF=(词在文档中出现的次数)/(文档总词数)<br>IDF=log(语料库中文档总数/(包含该词的文档数+1))<br>TF-IDF= TF*IDF<br>TF-IDF值越大，则这个词成为一个关键词的概率就越大  </p>\n<h2 id=\"TextRank算法\"><a href=\"#TextRank算法\" class=\"headerlink\" title=\"TextRank算法\"></a><strong>TextRank</strong>算法</h2><p>1.先对文档分词,分词结束词性标注处理，并过滤掉一些停用词，保留我们需要的词性的单词，名词或者动词或形容词  </p>\n<p>2.将上述我们需要的词语构建一个关键词图，其中词语为图的节点，然后通过共现关系构造任意两点之间的边，两个节点之间存在边仅当他们对应的词汇在长度为k的窗口中共现，K表示窗口的大小，即一个窗口单词的个数默认是5  </p>\n<p>3.根据PageRank原理中的衡量重要性的公式，初始化各节点的权重，然后迭代计算各节点的权重，直至收敛<br><img src=\"1.PNG\" alt=\"PageRank计算公式\"><br>4.对节点权重进行排序，选取得分最高的几个作为候选关键词</p>\n</blockquote>\n<h1 id=\"依存文法分析\"><a href=\"#依存文法分析\" class=\"headerlink\" title=\"依存文法分析\"></a>依存文法分析</h1><blockquote>\n<p>1.一个句子中只有一个成分是独立的  </p>\n<p>2.其它成分直接依存于某一成分  </p>\n<p>3.任何一个成分都不能依存与两个或两个以上的成分  </p>\n<p>4.如果A成分直接依存于B成分，而C成分在句中位于A和B之间，那么C或者直接依存于B，或者直接依存于A和B之间的某一成分  </p>\n<p>5.中心成分左右两面的其它成分相互不发生关系  </p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p> 主谓关系&nbsp;&nbsp;SBV&nbsp;(subject-verb)&nbsp;&nbsp;我送她一束花 (我 &lt;– 送)  </p>\n<p> 动宾关系&nbsp;&nbsp;VOB&nbsp;(verb-object)&nbsp;&nbsp;我送她一束花 (送 –&gt; 花)  </p>\n<p> 间宾关系&nbsp;&nbsp;IOB&nbsp;(indirect-object)&nbsp;&nbsp;我送她一束花 (送 –&gt; 她)  </p>\n<p>前置宾语&nbsp;&nbsp;FOB&nbsp;(fronting-object)&nbsp;&nbsp;他什么书都读 (书 &lt;– 读)  </p>\n<p> 并列关系&nbsp;&nbsp;COO&nbsp;(coordinate)&nbsp;&nbsp;大山和大海 (大山 –&gt; 大海)  </p>\n<p> 定中关系&nbsp;&nbsp;ATT&nbsp;(attribute)&nbsp;&nbsp;红苹果 (红 &lt;– 苹果)  </p>\n<p>兼语&nbsp;&nbsp;DBL&nbsp;(double)&nbsp;&nbsp;他请我吃饭 (请 –&gt; 我)  </p>\n<h2 id=\"句子结构\"><a href=\"#句子结构\" class=\"headerlink\" title=\"句子结构\"></a>句子结构</h2><p><strong>现代汉语结构：</strong> &nbsp;(定语)主语 + [状语]谓语 &lt;补语&gt; + (定语)宾语<br><img src=\"sentence.PNG\" alt=\"汉语结构\"></p>\n</blockquote>\n<h1 id=\"句子相似度计算\"><a href=\"#句子相似度计算\" class=\"headerlink\" title=\"句子相似度计算\"></a>句子相似度计算</h1><blockquote>\n<h2 id=\"1-句向量\"><a href=\"#1-句向量\" class=\"headerlink\" title=\"1.句向量\"></a>1.句向量</h2><p>1.对句子中的所有词的词向量进行加权平均(每个词向量的权重为<strong>a/(a+p(w))</strong><br><strong>a</strong> 代表参数，<strong>p(w)</strong> 代表词w的频率(相对整个预料的频率，不是指相对句子的频率)  </p>\n<p>2.使用<a href=\"https://github.com/siwanghu/Machine-Learning/blob/master/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.pdf\" target=\"_blank\" rel=\"noopener\">PCA算法</a>对生成的句向量降维<br><img src=\"2.png\" alt=\"句向量算法\"><br>参考论文<a href=\"https://openreview.net/pdf?id=SyK00v5xx\" target=\"_blank\" rel=\"noopener\">A Simple but Tough-to-Beat Baseline for Sentence Embeddings</a>  </p>\n<h2 id=\"2-EMD距离\"><a href=\"#2-EMD距离\" class=\"headerlink\" title=\"2.EMD距离\"></a>2.EMD距离</h2><p><strong>pip install pyemd</strong><br>首先将参与计算相似度的句子进行分词，去除停用词。接着查找词的词向量并计算每个词在所在句子中的词频。采用EMD距离计算短文本间的语义相似度，将一个句子的特征词向量全部“流向”另一个句子的特征词向量所经过的距离总和的最小值作为两个短文本之间的语义相似度。<br><img src=\"EMD.PNG\" alt=\"EMD算法\"><br><img src=\"ext.PNG\" alt=\"EMD举例\">  </p>\n<p><a href=\"https://github.com/wmayner/pyemd\" target=\"_blank\" rel=\"noopener\">pyemd参考资料</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://blog.csdn.net/index20001/article/details/77162495\" target=\"_blank\" rel=\"noopener\">EMD介绍</a>  </p>\n</blockquote>\n<h1 id=\"闲聊设计\"><a href=\"#闲聊设计\" class=\"headerlink\" title=\"闲聊设计\"></a>闲聊设计</h1><blockquote>\n<p><strong>1.使用seq2seq2模型，在tensorflow上实现</strong><br><strong>pip install tensorflow-gpu</strong><br><a href=\"https://github.com/siwanghu/chabot/blob/master/train.py\" target=\"_blank\" rel=\"noopener\">实现代码</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://blog.csdn.net/malefactor/article/details/78767781\" target=\"_blank\" rel=\"noopener\">注意力机制</a>  </p>\n<p><img src=\"seq2seq.png\" alt=\"模型图\">  </p>\n<p><strong>2.图灵机器人</strong><br><strong>pip install itchat</strong><br><a href=\"https://github.com/siwanghu/chabot/blob/master/wechat.py\" target=\"_blank\" rel=\"noopener\">实现代码</a>  </p>\n</blockquote>\n<h1 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h1><blockquote>\n<p><strong>pip install elasticsearch</strong><br>基于Lucene的全文搜索引擎<br><a href=\"http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html\" target=\"_blank\" rel=\"noopener\">入门教程</a>&nbsp;&nbsp;<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\" target=\"_blank\" rel=\"noopener\">官方教程</a>  </p>\n</blockquote>\n<h1 id=\"文本聚类\"><a href=\"#文本聚类\" class=\"headerlink\" title=\"文本聚类\"></a>文本聚类</h1><blockquote>\n<h2 id=\"1-产品\"><a href=\"#1-产品\" class=\"headerlink\" title=\"1.产品\"></a>1.产品</h2><p>第1类：  [‘请问你们的云视频会议产品可以作二次开发吗’, ‘请问你们的产品是否提供开放式’]<br>第2类：  [‘产品大概多少钱啊’, ‘什么样的产品’]<br>第3类：  [‘上次有找你们了解过你们的产品’, ‘不了解你们的产品’]<br>第4类：  [‘之前没有用过你们家产品’, ‘产品可以发过来体验’]<br>第5类：  [‘产品试用的人数有限制嘛’, ‘你们产品如何试用’]<br>第6类：  [‘您是需要什么产品吗’, ‘请问我需要产品的价格的话’]<br>第7类：  [‘你们公司的产品是做视频直播的’, ‘公司已经估使用你们的产品了’]<br>第8类：  [‘个人能够购买你们的产品吗’, ‘产品在线购买是怎么操作’]<br>第9类：  [‘如果作为加入会议的一方还需要购买咱们的产品吗’, ‘如果是发起会议就必须付费购买产品吧’]<br>第10类：  [‘你们的产品网络视频会议系统’, ‘你们的网络直播产品’]<br>第11类：  [‘产品使用’, ‘你们的产品怎么使用啊’]<br>第12类：  [‘产品的收费标准我看一下’, ‘你们产品的收费是怎样的’]<br>第13类：  [‘刚有留联系方式咨询产品的’, ‘咨询一下你们外呼的产品’]<br>第14类：  [‘你们的产品是会议还是呼叫中心’, ‘关于呼叫中心的产品白皮书’]<br>第15类：  [‘介绍下你们产品呗’, ‘介绍下您家的产品’]<br>第16类：  [‘不能先给我个你们的产品介绍或方案么’, ‘产品介绍可以发给我看一下吗’]<br>第17类：  [‘你们的产品可以满足这个需求吗’, ‘刚才你们同事打电话咨询我的产品需求’]<br>第18类：  [‘你们这个产品是可以直接拨打其他人手机号加入电话会议的吗’, ‘我想问下你们这个产品是以网页的形式进行在线视频会议的吗’]<br>第19类：  [‘另外用你们的产品是需要下载软件的吗’, ‘就其他人不用下载你们的产品’]<br>第20类：  [‘你们卖的产品是软件吗’, ‘你们的产品是硬件还是软件啊’]<br>第21类：  [‘你们的产品可以满足这些要求么’, ‘你们的产品能满足这些功能吗’]<br>第22类：  [‘产品信息的收费情况’, ‘产品属于什么的’]<br>第23类：  [‘想了解一下咱们产品都在什么单位使用呢’, ‘想了解一下咱们的产品功能’]<br>第24类：  [‘会议产品费用如何’, ‘会议终端如果本身就是思科的产品’]<br>第25类：  [‘产品主要功能’, ‘产品功能’]<br>第26类：  [‘能安排一下产品经理和我联系吗’, ‘要不我就联系别的产品了’]<br>第27类：  [‘你们代理思科的产品吗’, ‘你们是代理的思科的产品吗’]<br>第28类：  [‘产品功能和报价’, ‘产品和报价’]<br>第29类：  [‘产品确定了’, ‘我不太清楚你们的产品’]<br>第30类：  [‘不知道咱们的产品是否支持’, ‘产品支持多人在线视频’]  </p>\n<h2 id=\"2-硬件\"><a href=\"#2-硬件\" class=\"headerlink\" title=\"2.硬件\"></a>2.硬件</h2><p>第1类：  [‘不需要买硬件对吧’, ‘不需要任何硬件’, ‘不需要其他硬件了吧’]<br>第2类：  [‘不是硬件’, ‘不是硬件’, ‘主要是硬件’]<br>第3类：  [‘但是我们想要带硬件的那种’, ‘你们是做软件还是硬件还是软件硬件一起做全套的’, ‘你们是用硬件实现视频会议还是纯软件’]<br>第4类：  [‘不用购买硬件’, ‘不购买额外的硬件’, ‘不需要另外购买硬件支持的’]<br>第5类：  [‘你们也提供硬件吧’, ‘你们公司做视频会议硬件吗’, ‘你们提供的是否包括硬件设备’]<br>第6类：  [‘你们这个是没有硬件的是吧’, ‘如果没有硬件’, ‘您这边没有硬件设备’]<br>第7类：  [‘你们的硬件终端包括哪些设备’, ‘宝利通的硬件终端可以通吗’, ‘我们还有思科硬件终端’]<br>第8类：  [‘一般视频会议需要些什么硬件设备’, ‘不需要硬件支持吗’, ‘会议室需要什么硬件支持呢’]<br>第9类：  [‘一年包含硬件吗’, ‘不用其他硬件’, ‘不用其他硬件吗’]<br>第10类：  [‘后期会有硬件视频会议需求’, ‘对硬件有什么需求吗’, ‘或者对硬件有什么需求你们也可以给我们方案’]  </p>\n</blockquote>\n<h1 id=\"方案设计\"><a href=\"#方案设计\" class=\"headerlink\" title=\"方案设计\"></a>方案设计</h1><blockquote>\n<p><strong>设计图</strong>  </p>\n<p><img src=\"scheme.PNG\" alt=\"方案\"><br><strong>方案步骤</strong><br>1.原始数据–&gt;数据分词–&gt;语料IDF计算 <strong>(计算原始语料数据词语IDF值)</strong>  </p>\n<p>2.原始数据–&gt;数据分词–&gt;Word2Vec词向量训练 <strong>(训练词向量)</strong>  </p>\n<p>3.Word2Vec词向量训练–&gt;同义词分析 <strong>(分析高频词同义词)</strong>  </p>\n<p>4.原始数据–&gt;数据分词–&gt;词频统计–&gt;高频词聚类–&gt;问题提取–&gt;意图分类 <strong>(意图提取)</strong>  </p>\n<p>5.意图分类–&gt;TF-IDF关键词提取–&gt;语义向量构建–&gt;文本聚类–&gt;问题分类 <strong>(问题细分)</strong>  </p>\n<p><strong>第4步：先按照提取问题中含有的关键字优先级 <em>(以词频表示优先级)</em> 对问题做出意图分类</strong><br><strong>第5步：对第4步中分类的每个意图分别采取文本聚类 <em>(语义向量构建)</em> 进一步对意图分类</strong>  </p>\n</blockquote>\n<h1 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h1><blockquote>\n<p><strong>python项目构建</strong>  </p>\n<p><a href=\"https://www.jianshu.com/p/81d20ccf5d13\" target=\"_blank\" rel=\"noopener\">参考资料</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"http://beginman.cn/python/2016/01/18/python-tools-dev/\" target=\"_blank\" rel=\"noopener\">构建工具</a>  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java多线程笔记","url":"http://yoursite.com/2018/10/31/java多线程笔记/","content":"<h1 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h1><blockquote>\n<h2 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1.基本概念\"></a><strong>1.基本概念</strong></h2><ul>\n<li><p>并发：交替执行多任务，不一定要同时  </p>\n</li>\n<li><p>并行：同时处理多个任务  </p>\n</li>\n<li><p>同步：程序发出一个调用，在没有得到结果之前，该调用就不返回，程序阻塞。但是一旦调用返回，就得到返回值  </p>\n</li>\n<li><p>异步：程序发出一个调用，这个调用就直接返回了，没有返回结果。当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、来通知调用者，或通过回调函数处理这个调用  </p>\n</li>\n<li><p>阻塞：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回  </p>\n</li>\n<li><p>非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程  </p>\n</li>\n<li><p>竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件  </p>\n</li>\n<li><p>临界区：导致竞态条件发生的代码区称作临界区  </p>\n</li>\n<li><p>死锁：多个线程互相等待对方释放锁，从而进入无限期等待状态  </p>\n</li>\n<li><p>活锁：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程  </p>\n</li>\n<li><p>饥饿：线程一直无法获得运行资源，导致一直没有运行  </p>\n</li>\n<li><p>上下文切换： CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等  </p>\n</li>\n<li><p>公平锁：多个线程按照申请锁的顺序来获取锁(Lock与Semaphore可以在构造函数中指定为公平锁)  </p>\n</li>\n<li><p>非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁(synchronized是一种非公平锁)  </p>\n</li>\n<li><p>可重入锁：在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁(synchronized是一个可重入锁)  </p>\n</li>\n<li><p>独享锁：指该锁一次只能被一个线程所持有(互斥锁)  </p>\n</li>\n<li><p>共享锁：指该锁可被多个线程所持有(读写锁)  </p>\n</li>\n<li><p>互斥锁：独享锁具体实现，在Java中是ReentrantLock类  </p>\n</li>\n<li><p>读写锁：共享锁具体实现，Java中的具体实现就是ReadWriteLock  </p>\n</li>\n<li><p>自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁  </p>\n</li>\n<li><p>乐观锁：总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现  </p>\n</li>\n<li><p>悲观锁： 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起  </p>\n</li>\n</ul>\n<h2 id=\"2-进程与线程的区别\"><a href=\"#2-进程与线程的区别\" class=\"headerlink\" title=\"2.进程与线程的区别\"></a><strong>2.进程与线程的区别</strong></h2><ul>\n<li><p>进程代表一个正在运行的程序  </p>\n</li>\n<li><p>进程是操作系统进行资源分配的基本单位  </p>\n</li>\n<li><p>线程是操作系统进行调度的基本单位  </p>\n</li>\n<li><p>一个程序至少有一个进程，一个进程至少有一个线程  </p>\n</li>\n<li><p>线程比进程划分更细，执行开销更小，并发性更高  </p>\n</li>\n<li><p>进程是一个实体，拥有独立的资源；同一个进程中的多个线程共享进程的资源  </p>\n</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<em>JVM在单个进程中运行，JVM中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是为何一个线程如何调用一个方法以及它的局部变量是保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步</em>  </p>\n<h2 id=\"3-多线程的优缺点\"><a href=\"#3-多线程的优缺点\" class=\"headerlink\" title=\"3.多线程的优缺点\"></a><strong>3.多线程的优缺点</strong></h2><p><strong>优点：</strong>  </p>\n<ul>\n<li>更好的资源利用</li>\n<li>更简单的编程模型  </li>\n<li>程序响应更灵敏  </li>\n</ul>\n<p><strong>缺点：</strong>  </p>\n<ul>\n<li>安全性问题(资源访问)  </li>\n<li>活跃性问题(死锁)  </li>\n<li>性能问题(上下文切换)  </li>\n</ul>\n<h2 id=\"4-如何避免死锁与活锁\"><a href=\"#4-如何避免死锁与活锁\" class=\"headerlink\" title=\"4.如何避免死锁与活锁\"></a><strong>4.如何避免死锁与活锁</strong></h2><ul>\n<li><p>加锁顺序<br>确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生  </p>\n</li>\n<li><p>加锁时限<br>获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求,回退并释放所有已经获得的锁  </p>\n</li>\n<li><p>死锁检测  </p>\n</li>\n<li><p>没有避免活锁的通用指南<br>需要开发者自己小心设计代码逻辑  </p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"Java线程\"><a href=\"#Java线程\" class=\"headerlink\" title=\"Java线程\"></a>Java线程</h1><blockquote>\n<p>java中定义了6种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态：  </p>\n<ul>\n<li><p>开始（New）：还没有调用 start() 方法的线程处于此状态  </p>\n</li>\n<li><p>可运行（Runnable）：已经调用了start()方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了CPU时间片，就可以运行线程  </p>\n</li>\n<li><p>阻塞（Blocked）：线程有可能会进入I/O交互，还可能调用sleep()方法，还有可能在当前线程当中有其它线程调用了join()方法，阻塞状态的线程是没有释放对象锁  </p>\n</li>\n<li><p>等待（Waiting）:一个线程处于等待状态，是由于执行了 3 个方法中的任意方法:Object.wait(),Thread.join()<br>LockSupport.park()  </p>\n</li>\n<li><p>定时等待（Timed waiting）：一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<br>Thread.sleep(sleeptime)<br>Object.wait(timeout)<br>Thread.join(timeout)<br>LockSupport.parkNanos(timeout)<br>LockSupport.parkUntil(timeout)  </p>\n</li>\n<li><p>终止(Terminated)：线程 run() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期  </p>\n</li>\n</ul>\n<p><img src=\"thread-state.png\" alt=\"图片\">  </p>\n<p><em>区别：进入waiting状态是线程主动的, 而进入blocked状态是被动的;相同点:都暂时停止线程的执行, 线程本身不会占用CPU时间片.区别是调用了sleep方法的线程直接受CPU调度, 而wait则是等待另外的java线程在持有同一个对象锁的同步块/方法中进行notify调用</em>  </p>\n</blockquote>\n<h1 id=\"Java线程创建\"><a href=\"#Java线程创建\" class=\"headerlink\" title=\"Java线程创建\"></a>Java线程创建</h1><blockquote>\n<ul>\n<li>继承Thread类  </li>\n<li>实现Runable接口  </li>\n<li>使用线程池(ThreadPoolExecutor)  </li>\n<li>实现callable接口  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CallableDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Callable&lt;Integer&gt; callable = () -&gt; new Random().nextInt(100);</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(callable);</span><br><span class=\"line\">        new Thread(future).start();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);//可能做一些事情</span><br><span class=\"line\">            System.out.println(future.get());</span><br><span class=\"line\">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"Thread中的重要方法\"><a href=\"#Thread中的重要方法\" class=\"headerlink\" title=\"Thread中的重要方法\"></a>Thread中的重要方法</h1><blockquote>\n<ul>\n<li><p>run - 线程的执行实体  </p>\n</li>\n<li><p>start - 线程的启动方法  </p>\n</li>\n<li><p>setName、getName - 可以通过 setName()、 getName() 来设置、获取线程名称  </p>\n</li>\n<li><p>setPriority、getPriority - 在 Java 中，所有线程在运行前都会保持在就绪状态，那么此时，哪个线程优先级高，哪个线程就有可能被先执行。可以通过 setPriority、getPriority 来设置、获取线程优先级  </p>\n</li>\n<li><p>setDaemon、isDaemon - 可以使用 setDaemon() 方法设置线程为守护线程；可以使用 isDaemon() 方法判断线程是否为守护线程  </p>\n</li>\n<li><p>isAlive - 可以通过 isAlive 来判断线程是否启动  </p>\n</li>\n<li><p>interrupt - 当一个线程运行时，另一个线程可以直接通过 interrupt() 方法中断其运行状态  </p>\n</li>\n<li><p>join - 使用 join() 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行  </p>\n</li>\n<li><p>Thread.sleep - 使用 Thread.sleep() 方法即可实现休眠  </p>\n</li>\n<li><p>Thread.yield - 可以使用 Thread.yield() 方法将一个线程的操作暂时让给其他线程执行  </p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"Java线程间通信\"><a href=\"#Java线程间通信\" class=\"headerlink\" title=\"Java线程间通信\"></a>Java线程间通信</h1><blockquote>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a><strong>Object</strong></h2><p>wait、notify、notifyAll 是 Object 类中的方法  </p>\n<ul>\n<li>wait - 线程自动释放其占有的对象锁，并等待 notify  </li>\n<li><p>notify - 唤醒一个正在 wait 当前对象锁的线程，并让它拿到对象锁  </p>\n</li>\n<li><p>notifyAll - 唤醒所有正在 wait 前对象锁的线程  </p>\n</li>\n</ul>\n<p><strong>notify与notifyAll的区别</strong>  </p>\n<ul>\n<li><p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生  </p>\n</li>\n<li><p>唤醒在此对象监视器上等待的所有线程  </p>\n</li>\n</ul>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a><strong>管道</strong></h2><p>主要用于线程之间的数据传输，而传输的媒介为内存. 4 种具体实现：PipedOutputStream、PipedInputStream、PipedReader 和 PipedWriter，前两种面向字节，而后两种面向字符  </p>\n<p><em>ThreadLocal线程本地变量，ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Piped &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        PipedWriter out = new PipedWriter();</span><br><span class=\"line\">        PipedReader in = new PipedReader();</span><br><span class=\"line\">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class=\"line\">        out.connect(in);</span><br><span class=\"line\">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class=\"line\">        printThread.start();</span><br><span class=\"line\">        int receive = 0;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class=\"line\">                out.write(receive);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            out.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Print implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        private PipedReader in;</span><br><span class=\"line\"></span><br><span class=\"line\">        Print(PipedReader in) &#123;</span><br><span class=\"line\">            this.in = in;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            int receive = 0;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                while ((receive = in.read()) != -1) &#123;</span><br><span class=\"line\">                    System.out.print((char) receive);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"Java并发底层实现\"><a href=\"#Java并发底层实现\" class=\"headerlink\" title=\"Java并发底层实现\"></a>Java并发底层实现</h1><blockquote>\n<h2 id=\"1-synchronized\"><a href=\"#1-synchronized\" class=\"headerlink\" title=\"1.synchronized\"></a><strong>1.synchronized</strong></h2><p>关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块<br><strong>原理：</strong>  </p>\n<ul>\n<li><p>对于普通同步方法，锁是当前实例对象<br>造成其他的线程也无法调用当前类的其他同步方法  </p>\n</li>\n<li><p>对于静态同步方法，锁是当前类的 Class 对象  </p>\n</li>\n<li><p>对于同步方法块，锁是Synchonized 括号里配置的对象<br>同步方法块是细粒度的同步，推荐使用这种写法<br><em>注意：Java中的synchronized是可重入的，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的</em>  </p>\n<h2 id=\"2-volatile\"><a href=\"#2-volatile\" class=\"headerlink\" title=\"2.volatile\"></a><strong>2.volatile</strong></h2><p>volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”  </p>\n</li>\n</ul>\n<p>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值  </p>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。禁止进行指令重排序。如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的  </p>\n</blockquote>\n<h1 id=\"Lock锁\"><a href=\"#Lock锁\" class=\"headerlink\" title=\"Lock锁\"></a>Lock锁</h1><blockquote>\n<p><strong>synchronized缺陷</strong>  </p>\n<ul>\n<li><p>被synchronized修饰的方法或代码块，只能被一个线程访问。如果这个线程被阻塞，其他线程也只能等待</p>\n</li>\n<li><p>synchronized 不能响应中断  </p>\n</li>\n<li><p>synchronized 没有超时机制  </p>\n</li>\n<li><p>synchronized 只能是非公平锁  </p>\n</li>\n</ul>\n<p><img src=\"lock.PNG\" alt=\"图片\">  </p>\n<p><strong>Lock接口</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Lock &#123;</span><br><span class=\"line\">    void lock();</span><br><span class=\"line\">    void lockInterruptibly() throws InterruptedException;</span><br><span class=\"line\">    boolean tryLock();</span><br><span class=\"line\">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class=\"line\">    void unlock();</span><br><span class=\"line\">    Condition newCondition();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>lock() 方法的作用是获取锁。如果锁已被其他线程获取，则进行等待  </p>\n</li>\n<li><p>tryLock() 方法的作用是尝试获取锁，如果成功，则返回 true；如果失败（即锁已被其他线程获取），则返回 false。也就是说，这个方法无论如何都会立即返回，获取不到锁时不会一直等待  </p>\n</li>\n<li><p>lockInterruptibly() 方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 threadB.interrupt() 方法能够中断线程 B 的等待过程。<br><em>当一个线程获取了锁之后，是不会被 interrupt() 方法中断的。因为本身在前面的文章中讲过单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过 lockInterruptibly() 方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的</em>  </p>\n</li>\n<li><p>unlock() 方法的作用是释放锁  </p>\n</li>\n</ul>\n<p>ReentrantLock(可重入锁)是唯一实现了 Lock 接口的类<br><strong>ReadWriteLock 和 ReentrantReadWriteLock</strong><br>eadWriteLock 允许多个线程同时对其执行读操作，但是只允许一个线程对其执行写操作  </p>\n<p>ReentrantReadWriteLock 实现了 ReadWriteLock 接口，所以它是一个读写锁  </p>\n<p><strong>ReadWriteLock接口定义</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ReadWriteLock &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 返回用于读操作的锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Lock readLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 返回用于写操作的锁</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Lock writeLock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><strong>condition接口</strong><br>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> class BoundedBuffer &#123;</span><br><span class=\"line\">   final Lock lock = new ReentrantLock();</span><br><span class=\"line\">   final Condition notFull  = lock.newCondition(); </span><br><span class=\"line\">   final Condition notEmpty = lock.newCondition(); </span><br><span class=\"line\"></span><br><span class=\"line\">   final Object[] items = new Object[100];</span><br><span class=\"line\">   int putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void put(Object x) throws InterruptedException &#123;</span><br><span class=\"line\">     lock.lock();</span><br><span class=\"line\">     try &#123;</span><br><span class=\"line\">       while (count == items.length) </span><br><span class=\"line\">         notFull.await();</span><br><span class=\"line\">       items[putptr] = x; </span><br><span class=\"line\">       if (++putptr == items.length) putptr = 0;</span><br><span class=\"line\">       ++count;</span><br><span class=\"line\">       notEmpty.signal();</span><br><span class=\"line\">     &#125; finally &#123;</span><br><span class=\"line\">       lock.unlock();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public Object take() throws InterruptedException &#123;</span><br><span class=\"line\">     lock.lock();</span><br><span class=\"line\">     try &#123;</span><br><span class=\"line\">       while (count == 0) </span><br><span class=\"line\">         notEmpty.await();</span><br><span class=\"line\">       Object x = items[takeptr]; </span><br><span class=\"line\">       if (++takeptr == items.length) takeptr = 0;</span><br><span class=\"line\">       --count;</span><br><span class=\"line\">       notFull.signal();</span><br><span class=\"line\">       return x;</span><br><span class=\"line\">     &#125; finally &#123;</span><br><span class=\"line\">       lock.unlock();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"Semaphore信号量\"><a href=\"#Semaphore信号量\" class=\"headerlink\" title=\"Semaphore信号量\"></a>Semaphore信号量</h1><blockquote>\n<p>Semaphore用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量<br><strong>原理</strong>：Semaphore管理着一组虚拟的许可（permit），permit的初始数量可通过构造方法来指定。每次执行acquire方法可以获取一个permit，如果没有就等待；而release方法可以释放一个permit  </p>\n<ul>\n<li>Semaphore 可以用于实现资源池，如数据库连接池  </li>\n<li>Semaphore 可以用于将任何一种容器变成有界阻塞容器<br>Semaphore构造方法  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//初始化固定数量的 permit，并且默认为非公平模式</span><br><span class=\"line\">public Semaphore(int permits) &#123;&#125;</span><br><span class=\"line\">//初始化固定数量的 permit，第二个参数设置是否为公平模式。所谓公平，是指等待久的优先获取许可</span><br><span class=\"line\">public Semaphore(int permits, boolean fair) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Semaphore的重要方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取 1 个许可</span><br><span class=\"line\">public void acquire() throws InterruptedException &#123;&#125;</span><br><span class=\"line\">//获取 permits 个许可</span><br><span class=\"line\">public void acquire(int permits) throws InterruptedException &#123;&#125;</span><br><span class=\"line\">// 释放 1 个许可</span><br><span class=\"line\">public void release() &#123;&#125;</span><br><span class=\"line\">//释放 permits 个许可</span><br><span class=\"line\">public void release(int permits) &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>程序Demo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SemaphoreDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final int THREAD_COUNT = 30;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Semaphore s = new Semaphore(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    s.acquire();</span><br><span class=\"line\">                    System.out.println(&quot;save data&quot;);</span><br><span class=\"line\">                    s.release();</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><blockquote>\n<p> <strong>Semaphore与Lock的区别</strong>  </p>\n<ul>\n<li>Semaphore可以同时允许规定数量的线程执行  </li>\n<li>Lock对于不同的线程是互斥  </li>\n<li>Semaphore与Lock可以提供公平和不公平锁</li>\n</ul>\n<p><strong>synchronized与Lock的区别</strong>  </p>\n<ul>\n<li>synchronized 是Java 语言层面的，是内置的关键字  </li>\n<li>synchronized 同步的代码块可以由JVM自动释放  </li>\n<li>lock在性能上较好，支持公平锁和非公平锁  </li>\n<li>对于wait()方法，lock提供了condition可以提供更精确的临界区操作  </li>\n</ul>\n</blockquote>\n<h1 id=\"Java中的多线程同步手段\"><a href=\"#Java中的多线程同步手段\" class=\"headerlink\" title=\"Java中的多线程同步手段\"></a>Java中的多线程同步手段</h1><blockquote>\n<ul>\n<li>同步方法  </li>\n<li>同步代码块  </li>\n<li>使用volatile变量  </li>\n<li>可重入锁  </li>\n<li>尽量使用局部变量  </li>\n</ul>\n</blockquote>\n<h1 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h1><blockquote>\n<p><em>以上所述，只能保证在同一个JVM中的线程安全，在不同JVM（也就是分布式环境中）要保证线程安全，需要使用分布式锁</em>  </p>\n<p>在分布式的集群环境中<strong>使用Redis实现分布式锁</strong><br>Redis分布式锁基本流程：  </p>\n<ul>\n<li><p><strong>1.加锁</strong><br>使用setnx命令，其中key是锁的唯一标识（可以按照业务命名），加锁伪代码：setnx(key,1)。当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败  </p>\n</li>\n<li><p><strong>2.解锁</strong><br>当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入，释放锁的最简单方式是执行del命令：del key  </p>\n</li>\n<li><p><strong>3.锁超时</strong><br>如果一个得到锁的线程在执行任务时挂掉，来不及显示释放锁，这块资源将被永远锁住，别的线程再也无法获取锁（Lock，synchronized线程挂掉，锁会自动释放）,所以setnx的key必须设置一个超时时间，以保证即使没有被显示释放，一段时间后自动释放,需要额外命令：expire key 30  </p>\n</li>\n</ul>\n<p><strong>重要问题</strong>  </p>\n<ul>\n<li><p>由于setnx与expire是两个命令，必须要保证setnx与expire原子执行，如果setnx命令执行后,线程挂掉，锁会永远无法释放<br><em>Redis2.6.12版本以上增加set(key,1,30,nx取代以上两个命令)</em>  </p>\n</li>\n<li><p>锁误删<br>由于超时时间设置不对，造成锁时间失效，误删除。从而其它线程获取锁，当前线程会删除其他线程的锁（可以通过设置线程ID为key来解决误删其他线程的锁）。同时也可以设置守护线程来为锁续航。增加时间（如果当前线程在锁规定时间内没有结束，则守护线程增加锁的时间）  </p>\n</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java容器笔记","url":"http://yoursite.com/2018/10/31/java容器笔记/","content":"<h1 id=\"Java容器\"><a href=\"#Java容器\" class=\"headerlink\" title=\"Java容器\"></a>Java容器</h1><blockquote>\n<p>Java中常用的存储容器是数组与容器，但是两者有重大区别：  </p>\n<ul>\n<li>数组是固定长度的，容器的长度是可变的  </li>\n<li>数组可以存储基本数据类型，以可以存储引用数据类型；容器只能存储引用数据类型，基本数据类型要转成对应的包装类中才能放入容器  <h2 id=\"1-容器框架\"><a href=\"#1-容器框架\" class=\"headerlink\" title=\"1.容器框架\"></a><strong>1.容器框架</strong></h2><img src=\"container-structure.png\" alt=\"图片\">  </li>\n</ul>\n<p><img src=\"cc.PNG\" alt=\"图片\">  </p>\n<p>Java 容器框架主要分为Collection和Map两种。其中，Collection又分为List、Set 、Queue    </p>\n<ul>\n<li>Collection：一个独立元素的序列，这些元素都服从一条或者多条规则  </li>\n<li>List：必须按照插入的顺序保存元素  </li>\n<li>Set：不能有重复的元素  </li>\n<li>Map：一组成对的“键值对”对象，允许你使用键来查找值  <h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a><strong>set</strong></h2></li>\n<li><p>TreeSet是采用树结构实现(红黑树算法)；元素是按顺序（不是插入顺序）进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log(n))。存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素  </p>\n</li>\n<li><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)  </p>\n</li>\n<li><p>LinkedHashSet介于HashSet和TreeSet之间。它也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)  </p>\n</li>\n</ul>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a><strong>Map</strong></h2><ul>\n<li><p>HashMap：底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同步的。(同步使用hashtable替代)  </p>\n</li>\n<li><p>TreeMap：底层是二叉树(红黑树算法)数据结构。线程不同步。可以用于给map集合中的键进行排序存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素  </p>\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a><strong>List</strong></h2><ul>\n<li><p>ArrayList：数组，容量一大，频繁增删就是噩梦，适合随机查找  </p>\n</li>\n<li><p>LinkedList：基于链表的数据结构  </p>\n</li>\n<li><p>Vector：底层用数组实现的List，相关的方法都加了同步检查  </p>\n</li>\n</ul>\n<h2 id=\"String、StringBuilder、StringBuffer\"><a href=\"#String、StringBuilder、StringBuffer\" class=\"headerlink\" title=\"String、StringBuilder、StringBuffer\"></a><strong>String、StringBuilder、StringBuffer</strong></h2><ul>\n<li><p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的  </p>\n</li>\n<li><p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的  </p>\n</li>\n<li><p>String：适用于少量的字符串操作的情况；StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况  </p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"同步容器\"><a href=\"#同步容器\" class=\"headerlink\" title=\"同步容器\"></a>同步容器</h1><blockquote>\n<ul>\n<li><p>Vector 实现了 List 接口，Vector 实际上就是一个数组，和 ArrayList 类似，但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施  </p>\n</li>\n<li><p>Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类  </p>\n</li>\n<li><p>HashTable 实现了 Map 接口，它和 HashMap 很相似，但是 HashTable 进行了同步处理，而 HashMap 没有  </p>\n</li>\n<li><p>Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXxxx 等方法）  </p>\n</li>\n<li><p>字符串处理上，StringBuilder是线程不安全的，而StringBuffer是线程安全的  </p>\n</li>\n</ul>\n<p><em>同步容器未必安全。在做复合操作(调用容器中的多个方法)时，仍然需要加锁来保护</em>  </p>\n</blockquote>\n<h1 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h1><blockquote>\n<p>JDK 的 java.util.concurrent 包（即 juc）中提供了几个非常有用的并发容器  </p>\n<ul>\n<li>CopyOnWriteArrayList - 线程安全的 ArrayList  </li>\n<li>CopyOnWriteArraySet - 线程安全的 Set，它内部包含了一个 CopyOnWriteArrayList，因此本质上是由 CopyOnWriteArrayList 实现的  </li>\n<li>ConcurrentSkipListSet - 相当于线程安全的 TreeSet。它是有序的 Set。它由 ConcurrentSkipListMap 实现  </li>\n<li>ConcurrentHashMap - 线程安全的 HashMap。采用分段锁实现高效并发  </li>\n<li>ConcurrentSkipListMap - 线程安全的有序 Map。使用跳表实现高效并发  </li>\n<li>ConcurrentLinkedQueue - 线程安全的无界队列。底层采用单链表。支持 FIFO  </li>\n<li>ConcurrentLinkedDeque - 线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO  </li>\n<li>ArrayBlockingQueue - 数组实现的阻塞队列  </li>\n<li>LinkedBlockingQueue - 链表实现的阻塞队列  </li>\n<li>LinkedBlockingDeque - 双向链表实现的双端阻塞队列  </li>\n</ul>\n</blockquote>\n<h1 id=\"同步容器与并发容器的区别\"><a href=\"#同步容器与并发容器的区别\" class=\"headerlink\" title=\"同步容器与并发容器的区别\"></a>同步容器与并发容器的区别</h1><blockquote>\n<ul>\n<li>同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行,在高并发环境下，程序执行效率很低  </li>\n</ul>\n<ul>\n<li><p>同步类容器最大的缺点是读写都同步，这样在高并发环境下，性能非常的差  </p>\n</li>\n<li><p>并发容器：并发容器替换同步容器，是针对多个线程并发访问设计的,用很小的风险换得了可扩展性的提高  </p>\n</li>\n<li><p>并发容器并不能实时保证数据的一致性，它只能保证数据最终一致性  </p>\n</li>\n<li><p>并发容器非常占用内存，因为写时需要复制一份副本，对象非常大时，容易触发gc  </p>\n</li>\n<li><p>并发容器适用于读操作多写操作少的场景  </p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h1><blockquote>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Copy-On-Write简称COW，其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略  </p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;CopyOnWrite容器即写时复制的容器。当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器  </p>\n</blockquote>\n<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><blockquote>\n<p> &nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap本质上是一个Segment数组，而一个Segment实例又包含若干个桶，每个桶中都包含一条由若干个HashEntry对象链接起来的链表,ConcurrentHashMap是一个二级哈希表，单个Segment实际上就是传统意义上HashMap<br><img src=\"./ConcurrentHashMap.jpg\" alt=\"图片\">  </p>\n<ul>\n<li>通过锁分段技术保证并发环境下的写操作<br><em>ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高</em></li>\n<li>通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作  </li>\n<li><p>通过不加锁和加锁两种方案控制跨段操作的的安全性  </p>\n</li>\n<li><p>Case1：不同Segment的并发写入  </p>\n</li>\n</ul>\n<p><img src=\"case1.PNG\" alt=\"图片\"><br><em>由于锁分段技术的采用，不同Segment的写入是可以并发执行的</em>  </p>\n<ul>\n<li>Case2：同一Segment的一写一读  </li>\n</ul>\n<p><img src=\"case2.PNG\" alt=\"图片\"><br><em>同一Segment的写和读是可以并发执行的</em>  </p>\n<ul>\n<li>Case3：同一Segment的并发写入  </li>\n</ul>\n<p><img src=\"case3.PNG\" alt=\"图片\"><br><em>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞</em>  </p>\n<p>Get方法：1.为输入的Key做Hash运算，得到hash值。2.通过hash值，定位到对应的Segment对象。3.再次通过hash值，定位到Segment当中数组的具体位置  </p>\n<p>Put方法：1.为输入的Key做Hash运算，得到hash值。2.通过hash值，定位到对应的Segment对象。3.获取可重入锁。4.再次通过hash值，定位到Segment当中数组的具体位置。5.插入或覆盖HashEntry对象。6.释放锁  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"jvm-gc笔记","url":"http://yoursite.com/2018/10/31/jvm-gc笔记/","content":"<h1 id=\"Jvm-GC笔记\"><a href=\"#Jvm-GC笔记\" class=\"headerlink\" title=\"Jvm GC笔记\"></a>Jvm GC笔记</h1><blockquote>\n<h2 id=\"内存申请过程\"><a href=\"#内存申请过程\" class=\"headerlink\" title=\"内存申请过程\"></a>内存申请过程</h2><ul>\n<li><p>JVM会试图判别对象大小，如果是大对象则会优先在老年代中分配，如果这个时候老年代的空间不够，则会触发full GC；如果是小对象，则会在Eden空间中分配内存  </p>\n</li>\n<li><p>当Edge空间足够时，内存申请结束  </p>\n</li>\n<li><p>JVM试图释放在Eden中所有不活跃的对象（触发minor GC），释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区  </p>\n</li>\n<li><p>Survivor区被用来作为Eden及old的中间交换区域，当old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区  </p>\n</li>\n<li><p>当old区空间不够时，JVM会触发full GC  </p>\n</li>\n<li><p>完全垃圾收集后，若Survivor及old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现Out of memory错误  </p>\n</li>\n</ul>\n<h2 id=\"对象衰老过程\"><a href=\"#对象衰老过程\" class=\"headerlink\" title=\"对象衰老过程\"></a>对象衰老过程</h2><p>新创建的对象的内存分配自eden区。Minor GC的过程就是将eden和survivor中的活对象copy到空闲survivor 空间中。对象在young generation里经历了一定次数(可以通过参数配置)的minor GC后，就会被移到old generation中，称为tenuring  </p>\n<h2 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h2><p><a href=\"https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html\" target=\"_blank\" rel=\"noopener\">官方参数说明</a>  </p>\n<p><strong>-Xms</strong>    初始堆大小  </p>\n<hr>\n<p><strong>-Xmx</strong>    最大堆大小  </p>\n<hr>\n<p><strong>-Xmn</strong>    年轻代大小  </p>\n<hr>\n<p><strong>-XX:NewSize</strong> 设置年轻代初始值  </p>\n<hr>\n<p><strong>-XX:MaxNewSize</strong> 年轻代最大值  </p>\n<hr>\n<p><strong>-XX:PermSize</strong>    设置持久代初始值  </p>\n<hr>\n<p><strong>-XX:MaxPermSize</strong>  设置持久代最大值  </p>\n<hr>\n<p><strong>-Xss</strong> 每个线程的堆栈大小  </p>\n<hr>\n<p><strong>-XX:NewRatio</strong>    年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)  </p>\n<hr>\n<p><strong>-XX:SurvivorRatio</strong>    Eden区与Survivor区的大小比值  </p>\n<hr>\n<p><strong>-XX:+DisableExplicitGC</strong> 关闭System.gc()  </p>\n<hr>\n<p><strong>-XX:MaxTenuringThreshold</strong>    垃圾最大年龄<br><em>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</em>  </p>\n<hr>\n<p><strong>-XX:PretenureSizeThreshold</strong> 对象超过多大是直接在老年代中分配<br><em>单位字节 新生代采用Parallel Scavenge GC时无效<br>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</em>   </p>\n<hr>\n<p><strong>-XX:+CollectGen0First</strong>    FullGC时是否先YGC  </p>\n<hr>\n<p><strong>吞吐量throughput（工作时间不算gc的时间占总的时间比）和暂停pause（gc发生时app对外显示的无法响应）</strong>  </p>\n<h2 id=\"年轻代大小选择\"><a href=\"#年轻代大小选择\" class=\"headerlink\" title=\"年轻代大小选择\"></a>年轻代大小选择</h2><ul>\n<li><p>响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象  </p>\n</li>\n<li><p>吞吐量优先的应用:尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用  </p>\n</li>\n<li><p>避免设置过小.当新生代设置过小时会导致:1.YGC次数更加频繁 2.可能导致YGC对象直接进入老年代,如果此时老年代满了,会触发FGC  </p>\n</li>\n</ul>\n<h2 id=\"年老代大小选择\"><a href=\"#年老代大小选择\" class=\"headerlink\" title=\"年老代大小选择\"></a>年老代大小选择</h2><ul>\n<li><p>响应时间优先的应用:年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎 片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:<br>并发垃圾收集信息、持久代并发收集次数、传统GC信息、花在年轻代和年老代回收上的时间比例  </p>\n</li>\n<li><p>吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.  </p>\n</li>\n</ul>\n<h2 id=\"大型网站服务器JVM参数配置举例\"><a href=\"#大型网站服务器JVM参数配置举例\" class=\"headerlink\" title=\"大型网站服务器JVM参数配置举例\"></a>大型网站服务器JVM参数配置举例</h2><p><strong>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC</strong>  </p>\n<ul>\n<li><p>-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间  </p>\n</li>\n<li><p>-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8,但要按照实际应用需要配置  </p>\n</li>\n<li><p>-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能  </p>\n</li>\n<li><p>-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8  </p>\n</li>\n<li><p>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0  </p>\n</li>\n<li><p>-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况  </p>\n</li>\n</ul>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>查看heap使用情况与jvm采用的gc策略<br><strong>jmap -heap pid</strong>  </p>\n<hr>\n<p>查看jvm程序工具<br>jconsole或jvisualvm或jprofiler  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"ros笔记","url":"http://yoursite.com/2018/10/31/ros笔记/","content":"<h1 id=\"Turtlebot学习笔记\"><a href=\"#Turtlebot学习笔记\" class=\"headerlink\" title=\"Turtlebot学习笔记\"></a>Turtlebot学习笔记</h1><h2 id=\"ubuntu14-04上安装ROS-Indigo版本\"><a href=\"#ubuntu14-04上安装ROS-Indigo版本\" class=\"headerlink\" title=\"ubuntu14.04上安装ROS Indigo版本\"></a>ubuntu14.04上安装ROS Indigo版本</h2><blockquote>\n<p><strong>设置安装软件源</strong><br>sudo sh -c ‘echo “deb <a href=\"http://packages.ros.org/ros/ubuntu\" target=\"_blank\" rel=\"noopener\">http://packages.ros.org/ros/ubuntu</a> $(lsb_release -sc) main” &gt; /etc/apt/sources.list.d/ros-latest.list’  </p>\n<p><strong>设置key</strong><br>sudo apt-key adv –keyserver hkp://ha.pool.sks-keyservers.net:80 –recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116  </p>\n<p><strong>安装</strong><br>sudo apt-get update<br>sudo apt-get install ros-indigo-desktop-full</p>\n<p><strong>初始化rosdep</strong><br>sudo rosdep init<br>rosdep update  </p>\n<p><strong>初始化ROS开发环境</strong><br>echo “source /opt/ros/indigo/setup.bash” &gt;&gt; ~/.bashrc<br>source ~/.bashrc  </p>\n<p><strong>安装ROS工具包</strong><br>sudo apt-get install python-rosinstall</p>\n</blockquote>\n<h1 id=\"Turtlebot包安装\"><a href=\"#Turtlebot包安装\" class=\"headerlink\" title=\"Turtlebot包安装\"></a>Turtlebot包安装</h1><h2 id=\"安装ROS-Indigo对应的Turtlebot包\"><a href=\"#安装ROS-Indigo对应的Turtlebot包\" class=\"headerlink\" title=\"安装ROS Indigo对应的Turtlebot包\"></a>安装ROS Indigo对应的Turtlebot包</h2><blockquote>\n<p><strong>ubuntu软件安装源更新</strong><br>sudo apt-get update  </p>\n<p><strong>Turtlebot包安装</strong><br>sudo apt-get install ros-indigo-turtlebot ros-indigo-turtlebot-apps ros-indigo-turtlebot-interactions ros-indigo-turtlebot-simulator ros-indigo-kobuki-ftdi ros-indigo-rocon-remocon ros-indigo-rocon-qt-library ros-indigo-ar-track-alvar-msgs  </p>\n</blockquote>\n<h1 id=\"Turtlebot测试\"><a href=\"#Turtlebot测试\" class=\"headerlink\" title=\"Turtlebot测试\"></a>Turtlebot测试</h1><blockquote>\n<p><strong>启动ROS</strong><br>roscore  </p>\n<p><strong>设备驱动配置</strong><br>使用 ls /dev/kobuki命令，如果没有显示对应的设备驱动 <strong>/dev/kobuki</strong> 则使用命令 <strong>rosrun kobuki_ftdi create_udev_rules</strong> 添加，重启Turtlebot底盘即可  </p>\n<p><strong>键盘控制底盘</strong><br>roslaunch turtlebot_bringup minimal.launch<br>roslaunch turtlebot_teleop keyboard_teleop.launch  </p>\n<p><strong>通过发布主题命令控制底盘</strong><br>rostopic pub -r 10 /cmd_vel_mux/input/navi  geometry_msgs/Twist  ‘{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}’  </p>\n</blockquote>\n<h1 id=\"Kinect配置\"><a href=\"#Kinect配置\" class=\"headerlink\" title=\"Kinect配置\"></a>Kinect配置</h1><blockquote>\n<p><strong>安装驱动</strong><br>sudo apt-get install ros-indigo-openni-<em> ros-indigo-openni2-</em> ros-indigo-freenect-*<br>rospack profile  </p>\n<p><strong>设置环境变量(非常重要,做任何事之前都要查看和配置)</strong><br>echo $TURTLEBOT_3D_SENSOR<br>如果输出的不是kinect则需要重新配置  </p>\n<p><strong>如果你看到一个3D传感器，例如asus_xtion_pro，您将需要设置环境变量的默认值，修改和重新启动终端：</strong><br>echo “export TURTLEBOT_3D_SENSOR=kinect” &gt;&gt; .bashrc  </p>\n</blockquote>\n<h1 id=\"Kinect测试\"><a href=\"#Kinect测试\" class=\"headerlink\" title=\"Kinect测试\"></a>Kinect测试</h1><blockquote>\n<p><strong>启动turtlebot</strong><br>roslaunch turtlebot_bringup minimal.launch  </p>\n<p><strong>启动Kinect</strong><br>roslaunch freenect_launch freenect-registered-xyzrgb.launch （Kinect新版本）<br>roslaunch openni_launch openni.launch (Kinect或旧版本)<br><strong>针对Asus Xtion, Xtion Pro, or Primesense 1.08/1.09 cameras:</strong><br>roslaunch openni2_launch openni2.launch depth_registration:=true  </p>\n<ul>\n<li>图片 rosrun image_view image_view image:=/camera/rgb/image_color  <ul>\n<li>深度图 rosrun image_view image_view image:=/camera/depth_registered/image  </li>\n</ul>\n</li>\n</ul>\n<p><strong>在RVIZ上查看相机</strong><br>roslaunch turtlebot_bringup 3dsensor.launch<br>roslaunch turtlebot_rviz_launchers view_robot.launch  </p>\n</blockquote>\n<h1 id=\"Turtlebot跟随\"><a href=\"#Turtlebot跟随\" class=\"headerlink\" title=\"Turtlebot跟随\"></a>Turtlebot跟随</h1><blockquote>\n<p><strong>启动Turtlebot</strong><br>roslaunch turtlebot_bringup minimal.launch  </p>\n<p><strong>启动跟随脚本</strong><br>roslaunch turtlebot_follower follower.launch  </p>\n</blockquote>\n<h1 id=\"Turtlebot建图导航\"><a href=\"#Turtlebot建图导航\" class=\"headerlink\" title=\"Turtlebot建图导航\"></a>Turtlebot建图导航</h1><h2 id=\"创建地图\"><a href=\"#创建地图\" class=\"headerlink\" title=\"创建地图\"></a>创建地图</h2><blockquote>\n<p><strong>启动Turtlebot</strong> <em>roslaunch turtlebot_bringup minimal.launch</em>  </p>\n<p><strong>创建地图</strong> <em>roslaunch turtlebot_navigation gmapping_demo.launch</em>  </p>\n<p><strong>打开rviz</strong> <em>roslaunch turtlebot_rviz_launchers view_navigation.launch</em>  </p>\n<p><strong>手动扫描建图</strong> <em>roslaunch turtlebot_teleop keyboard_teleop.launch</em>  </p>\n<p><strong>保存地图</strong> <em>rosrun map_server map_saver -f /tmp/my_map</em>  </p>\n</blockquote>\n<h2 id=\"自主导航\"><a href=\"#自主导航\" class=\"headerlink\" title=\"自主导航\"></a>自主导航</h2><blockquote>\n<p><strong>启动Turtlebot</strong> <em>roslaunch turtlebot_bringup minimal.launch</em>  </p>\n<p><strong>启动导航模块</strong> <em>roslaunch turtlebot_navigation amcl_demo.launch map_file:=/tmp/my_map.yaml</em>  </p>\n<p>导航模块有时启动失败可以使用这种方式启动(<strong>非常重要</strong>)<br>export TURTLEBOT_MAP_FILE=～/tmp/my_map.yaml<br>roslaunch turtlebot_navigation amcl_demo.launch  </p>\n<p><strong>打开rviz</strong> <em>roslaunch turtlebot_rviz_launchers view_navigation.launch –screen</em>  </p>\n<p><strong>当启动之后，TurtleBot并不知道自己在哪个位置,需要给它提供它在地图上的位置：</strong>  </p>\n<ul>\n<li>点击rviz中的”2D Pose Estimate”按钮</li>\n<li>在地图上标出TurtleBot的近似位置，并指出TurtleBot的朝向（TurtleBot的正运动方向)  </li>\n<li>点击rviz上的”2D Nav Goal”按钮  </li>\n<li>在地图上标出TurtleBot的导航目标，并且指出其在导航终点的朝向  </li>\n</ul>\n</blockquote>\n<h1 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h1><blockquote>\n<p>主机也需要和笔记本一样安装ROS和Turtlebot包(<strong>参考上面ROS与Turtlebot包安装过程</strong>)  </p>\n<p>主机与笔记本需要同步时钟，在主机与笔记本上都需要安装chrony(<strong>非常重要</strong>)<br>sudo apt-get install chrony<br>sudo ntpdate ntp.ubuntu.com  </p>\n<p>在主机和笔记本电脑上都需要安装ssh-server<br>sudo apt-get install openssh-server  </p>\n<p>在笔记本电脑端配置<br>echo export ROS_MASTER_URI=<a href=\"http://localhost:11311\" target=\"_blank\" rel=\"noopener\">http://localhost:11311</a> &gt;&gt; ~/.bashrc<br>echo export ROS_HOSTNAME=<strong>笔记本电脑IP地址</strong> &gt;&gt; ~/.bashrc  </p>\n<p>在主机端配置<br>echo export ROS_MASTER_URI=http://<strong>笔记本电脑IP地址</strong>:11311 &gt;&gt; ~/.bashrc<br>echo export ROS_HOSTNAME=<strong>主机IP地址</strong> &gt;&gt; ~/.bashrc  </p>\n</blockquote>\n<h2 id=\"网络测试\"><a href=\"#网络测试\" class=\"headerlink\" title=\"网络测试\"></a>网络测试</h2><blockquote>\n<p>主机开启一个终端使用ssh命令登陆笔记本电脑<br>ssh username@ip<br>运行roscore  </p>\n<p>主机在开启一个终端使用ssh命令登陆笔记本电脑<br>ssh username@ip<br>运行roslaunch turtlebot_bringup minimal.launch  </p>\n<p>在主机开启一个终端<br>运行roslaunch turtlebot_teleop keyboard_teleop.launch<br>如果在主机端可以操作Turtlebot,说明网络配置成功  </p>\n</blockquote>\n<h1 id=\"ROS常用命令\"><a href=\"#ROS常用命令\" class=\"headerlink\" title=\"ROS常用命令\"></a>ROS常用命令</h1><blockquote>\n<p>实时查看机器人坐标位置<br>rosrun tf tf_echo /map /base_link</p>\n</blockquote>\n<h1 id=\"ROS工作原理\"><a href=\"#ROS工作原理\" class=\"headerlink\" title=\"ROS工作原理\"></a>ROS工作原理</h1><blockquote>\n<h2 id=\"ROS节点\"><a href=\"#ROS节点\" class=\"headerlink\" title=\"ROS节点\"></a><strong>ROS节点</strong></h2><p>使用命令<strong>rosnode</strong>查看Turtlebot运行启动时运行的ROS结点  </p>\n<p>ROS 的一个基本目标是使机器人的很多节点node（可执行文件，几乎相对独立的小程序）能够同时运行。为此，这些节点必须能够彼此通信。ROS 中实现通信的关键部分就是ROS节点管理器。要启动节点管理器，使用如下命令：<strong>roscore</strong>。节点管理器应该在使用ROS的全部时间内持续运行。一个合理的工作流程是在一个终端启动roscore，然后打开其他终端运行其他程序。  </p>\n<p><strong>/rosout</strong><br>rosout节点是一个特殊的节点，通过 roscore 自动启动。其作用有点类似于控制台程序中使用的标准输出（即 std::cout）。/rosout也是话题，所有的节点发布都向话题/rosout 发布消息，该话题由同名的 /rosout 节点订阅。这个话题的作用是用来生成各个节点的文本日志消息。在某些地方/rosout 既指节点又指话题。但 ROS 并不会这种重复的名字而混淆，因为 ROS 会根据上下文来推测我们讨论的是/rosout节点,还是/rosout话题。  </p>\n<p><strong>/app_manager</strong><br>对于robot是一个公共接口结点,只需调用app_manager的接口就可以操控robot。  </p>\n<p><strong>/master</strong><br>master提供topic的命名和注册service功能，也提供跟踪sub/pub功能。这个节点的角色就是让A节点能够定位到B节点。然后两个节点AB之间进行点对点的通信。<br>也提供参数服务器功能。  </p>\n<h2 id=\"ROS主题\"><a href=\"#ROS主题\" class=\"headerlink\" title=\"ROS主题\"></a><strong>ROS主题</strong></h2><p>使用<strong>rostopic</strong>查看Turtlebox启动时运行的ROS主题  </p>\n<p>主题是由ROS网络对消息进行路由和消息管理的数据总线。每一条消息都要发布到相应的主题。当一个节点发送数据时，我们就说该节点正在向主题发布消息。节点可以通过订阅某个主题，接收来自其他节点的消息。一个节点可以订阅一个主题，而并不需要该节点同时发布该主题。这就保证了消息的发布者和订阅者之间相互解耦，完全无需知晓对方的存在。主题的名称必须是独一无二的，否则在同名主题之间的消息路由就会发生错误。  </p>\n<p><strong>/cmd_vel_mux/active</strong><br>记录每一刻的主动输入，如果没有人指挥机器人，就会闲置的话题  </p>\n<p><strong>/cmd_vel_mux/input/XXX</strong><br>多路复用器输入主题。可以在配置文件中描述任意数量的输入主题  </p>\n<h2 id=\"ROS消息\"><a href=\"#ROS消息\" class=\"headerlink\" title=\"ROS消息\"></a><strong>ROS消息</strong></h2><p><strong>rostopic info 节点名</strong>可以查看主题的消息类型  </p>\n<p>节点通过消息完成彼此的沟通。消息包含一个节点发送到其他节点的数据信息。ROS 中包含很多种标准类型的消息，同时你也可以基于标准消息开发自定义类型的消息  </p>\n<h2 id=\"ROS服务\"><a href=\"#ROS服务\" class=\"headerlink\" title=\"ROS服务\"></a><strong>ROS服务</strong></h2><p>可以使用<strong>rosservice</strong>命令查看当前的ROS服务  </p>\n<p>在发布主题时，正在发送的数据能够以多对多的方式交互。但当你需要从某个节点获得一个请求或应答时，就不能通过主题来实现了。在这种情况下，服务能够允许我们直接与某个节点进行交互。此外，服务必须有一个唯一的名称。当一个节点提供某个服务时，所有的节点都可以通过使用ROS 客户端库所编写的代码与它通信。  </p>\n<h2 id=\"ROS节点管理器\"><a href=\"#ROS节点管理器\" class=\"headerlink\" title=\"ROS节点管理器\"></a><strong>ROS节点管理器</strong></h2><p>节点管理器是ROS名称服务,能够帮助节点找到彼此。节点通过与节点管理器通信来报告他们的注册信息。值得注意的是,当这些节点和节点管理器通信时,它们可以接受其他注册节点的信息,并能保持通信正常。当这些注册信息改变时,节点管理器也会回调这些节点。所以,没有节点管理器,节点将不能相互找到,也不能进行消息交换或者调用服务。  </p>\n<h2 id=\"参数服务器\"><a href=\"#参数服务器\" class=\"headerlink\" title=\"参数服务器\"></a><strong>参数服务器</strong></h2><p>是节点管理器的一部分,其允许数据通过关键词来存储。可以在结点运行时配置结点或改变节点的工作模式  </p>\n<h2 id=\"消息记录包\"><a href=\"#消息记录包\" class=\"headerlink\" title=\"消息记录包\"></a><strong>消息记录包</strong></h2><p>使用<strong>rosbag record -a</strong>记录所有消息，消息记录包存放在当前文件夹下<br>使用<strong>rosbag play 包名</strong>回放消息  </p>\n<p>消息记录包是一种用于保存和回放 ROS 消息数据的格式。消息记录包是检索传感器数据的重要机制。它可以获取并记录各种传感器数据，我们可以通过消息记录包来反复获取实验数据  </p>\n<p><img src=\"ros.JPG\" alt=\"图片\">  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"java流笔记","url":"http://yoursite.com/2018/10/31/java流笔记/","content":"<h1 id=\"Java流\"><a href=\"#Java流\" class=\"headerlink\" title=\"Java流\"></a>Java流</h1><blockquote>\n<h2 id=\"字符流与字节流\"><a href=\"#字符流与字节流\" class=\"headerlink\" title=\"字符流与字节流\"></a><strong>字符流与字节流</strong></h2><p>Java IO中的流操作分为两类:</p>\n<ul>\n<li>字节流(byte)：主要是:InputStream（输入） 和 OutputStream（输出）  </li>\n<li>字符流：操作字符类型数据，一个字符占两个字节。主要是Reader（输入）和Writer（输出）<br><strong>流操作一般流程:</strong>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一.使用File类绑定一个文件。</span><br><span class=\"line\"></span><br><span class=\"line\">二.把File对象绑定到流对象上。</span><br><span class=\"line\"></span><br><span class=\"line\">三.进行读或写操作。</span><br><span class=\"line\"></span><br><span class=\"line\">四.关闭流</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><p>字节流主要操作字节类型数据（byte）；字符流主要操作字符类型数据，一个字符占两个字节  </p>\n</li>\n<li><p>字节流在操作时本身不会用到缓冲区（内存），而是对文件本身直接操作的；字符流在操作时使用了缓冲区，通过缓冲区再操作文件  </p>\n<h2 id=\"类框架图\"><a href=\"#类框架图\" class=\"headerlink\" title=\"类框架图\"></a><strong>类框架图</strong></h2><p><img src=\"io.png\" alt=\"图片\">  </p>\n</li>\n</ul>\n<ul>\n<li>InputStream是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class=\"line\">int read() ； </span><br><span class=\"line\"></span><br><span class=\"line\">//读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 </span><br><span class=\"line\">int read(byte[] buffer) ； </span><br><span class=\"line\"></span><br><span class=\"line\">//读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 </span><br><span class=\"line\">int read(byte[] buffer, int off, int len) ；</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Reader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class=\"line\">int read() ； </span><br><span class=\"line\"></span><br><span class=\"line\">//读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 </span><br><span class=\"line\">int read(char[] cbuf) ； </span><br><span class=\"line\"></span><br><span class=\"line\">//读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 </span><br><span class=\"line\">int read(char[] cbuf, int off, int len)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>OutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//向输出流中写入一个字节数据,该字节数据为参数b的低8位。 </span><br><span class=\"line\">void write(int b) ; </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字节类型的数组中的数据写入输出流。 </span><br><span class=\"line\">void write(byte[] b); </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 </span><br><span class=\"line\">void write(byte[] b, int off, int len); </span><br><span class=\"line\"></span><br><span class=\"line\">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class=\"line\">void flush();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Writer 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//向输出流中写入一个字符数据,该字节数据为参数b的低16位。 </span><br><span class=\"line\">void write(int c); </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字符类型的数组中的数据写入输出流， </span><br><span class=\"line\">void write(char[] cbuf) </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 </span><br><span class=\"line\">void write(char[] cbuf, int offset, int length); </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字符串中的字符写入到输出流。 </span><br><span class=\"line\">void write(String string); </span><br><span class=\"line\"></span><br><span class=\"line\">//将一个字符串从offset开始的length个字符写入到输出流。 </span><br><span class=\"line\">void write(String string, int offset, int length); </span><br><span class=\"line\"></span><br><span class=\"line\">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class=\"line\">void flush()</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"redis笔记","url":"http://yoursite.com/2018/10/31/redis笔记/","content":"<h1 id=\"Redis远程字典服务器\"><a href=\"#Redis远程字典服务器\" class=\"headerlink\" title=\"Redis远程字典服务器\"></a>Redis远程字典服务器</h1><blockquote>\n<p>Redis是速度非常快的非关系型（NoSQL）内存键值数据库  </p>\n</blockquote>\n<h1 id=\"Redis优点\"><a href=\"#Redis优点\" class=\"headerlink\" title=\"Redis优点\"></a>Redis优点</h1><blockquote>\n<ul>\n<li><p>性能极高，Redis 能读的速度是110000 次/s，写的速度是81000 次/s  </p>\n</li>\n<li><p>Redis 的所有操作都是原子性的。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来  </p>\n</li>\n<li><p>Redis 支持数据的持久化（RDB快照和AOF日志）  </p>\n</li>\n<li><p>Redis 支持数据的备份，即 master-slave 模式的数据备份  </p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"Redis启动\"><a href=\"#Redis启动\" class=\"headerlink\" title=\"Redis启动\"></a>Redis启动</h1><blockquote>\n<p>启动Redis&nbsp;&nbsp;<strong>redis-server.exe redis.windows.conf</strong><br>远程登陆&nbsp;&nbsp; <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong><br>停止Redis&nbsp;&nbsp; <strong>redis-cli.exe shutdown</strong><br>Redis默认启动端口为:&nbsp;&nbsp;<strong>6379</strong>  </p>\n</blockquote>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><blockquote>\n<ul>\n<li>字符串  </li>\n<li>散列(哈希表)  </li>\n<li>列表  </li>\n<li>集合  </li>\n<li>有序集合  </li>\n</ul>\n</blockquote>\n<h1 id=\"有关键的命令\"><a href=\"#有关键的命令\" class=\"headerlink\" title=\"有关键的命令\"></a>有关键的命令</h1><blockquote>\n<p><strong>keys pattern</strong><br>获得符合pattern规则的键名列表  </p>\n<ul>\n<li>?&nbsp;&nbsp;匹配一个字符  </li>\n<li>*&nbsp;&nbsp;匹配任意个字符  </li>\n<li>[&nbsp;]&nbsp;&nbsp;匹配括号间的任一个字符  </li>\n<li>\\x&nbsp;&nbsp;匹配转义字符  </li>\n</ul>\n<hr>\n<p><strong>exists key</strong><br>判断一个键名是否存在<br><em>exists name&nbsp;&nbsp;判断键name是否存在</em>  </p>\n<hr>\n<p><strong>del key</strong><br>删除名字为key的键  </p>\n<hr>\n<p><strong>type key</strong><br>查看key键的数据类型  </p>\n</blockquote>\n<h1 id=\"字符串类型命令\"><a href=\"#字符串类型命令\" class=\"headerlink\" title=\"字符串类型命令\"></a>字符串类型命令</h1><blockquote>\n<p>string是Redis最基本的数据类型，可以存储任何形式的字符串，包括二进制数据，例如：图片，序列化的对象  </p>\n<hr>\n<p><strong>set key value</strong><br>设置键为key值为value  </p>\n<hr>\n<p><strong>get key</strong><br>获取键为key的value  </p>\n<hr>\n<p><strong>incr key</strong><br>如果key对应的值是整数形式,其value加1  </p>\n<hr>\n<p><strong>setnx key value</strong><br>将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。  </p>\n<hr>\n<p><strong>incrby key increment</strong><br>key对应的值是整数形式,其value加increment数  </p>\n<hr>\n<p><strong>decr key</strong><br><strong>decr key increment</strong><br>与incr功能相反  </p>\n<hr>\n<p><strong>incrbyfloat key increment</strong><br>增加指定的increment浮点数  </p>\n<hr>\n<p><strong>append key value</strong><br>向key对应的字符串连接上value  </p>\n<hr>\n<p><strong>strlen key</strong><br>获取key的value值字符串的长度  </p>\n<hr>\n<p><strong>mget key1 key2 key3</strong><br><strong>mset key1 v1 key2 v2</strong><br>同时设置多个键值对  </p>\n</blockquote>\n<h1 id=\"位操作命令\"><a href=\"#位操作命令\" class=\"headerlink\" title=\"位操作命令\"></a>位操作命令</h1><blockquote>\n<p><strong>getbit key offset</strong><br>获取key对应的value值的二进制位的第offset位  </p>\n<hr>\n<p><strong>setbit key offset value</strong><br>将key对应的value值的二进制位的第offset位值为value(0|1)  </p>\n<hr>\n<p><strong>bitcount key</strong><br>获取key对应的value值的二进制中1的个数<br><strong>bitcount key begOffset endOffset</strong>  </p>\n<hr>\n<p><strong>bitop or|and|xor|not</strong><br>bitop提供位运算<br>bitop or res key1 key2  </p>\n<hr>\n</blockquote>\n<h1 id=\"散列类型命令\"><a href=\"#散列类型命令\" class=\"headerlink\" title=\"散列类型命令\"></a>散列类型命令</h1><blockquote>\n<p>Redis中散列类型适合存储对象。一般我们使用对象类型与ID构成键名object:id  </p>\n<hr>\n<p><strong>hset key field value</strong><br>存储键名位key属性为field值为value<br>hset ustc:sa17225123 name siwanghu  </p>\n<hr>\n<p><strong>hget key field</strong><br>获取对象键名为key属性field的值<br>hget ustc:sa17225123 name  </p>\n<hr>\n<p><strong>hmset key field1 value1 field2 value2</strong><br><strong>hmget key field1 field2</strong><br>同时设置与获取对象键名为key的多个属性  </p>\n<hr>\n<p><strong>hgetall key</strong><br>获取对象键名为key的所有属性与属性对应的值<br>hgetall ustc:sa17225123  </p>\n<hr>\n<p><strong>hexists key field</strong><br>判断对象键名为key的属性field是否存在  </p>\n<hr>\n<p><strong>hsetnx key field value</strong><br>给对象键名为key赋值属性field对应值为value，如果属性不存在；如果属性field存在，则什么也不做  </p>\n<hr>\n<p><strong>hincrby key field increment</strong><br>属性field增加数字值increment  </p>\n<hr>\n<p><strong>hdel key field</strong><br>删除对象键名为key的属性field  </p>\n</blockquote>\n<h1 id=\"列表类型命令\"><a href=\"#列表类型命令\" class=\"headerlink\" title=\"列表类型命令\"></a>列表类型命令</h1><blockquote>\n<p><strong>lpush key value</strong><br>向列表key左边增加元素value<br><strong>rpush key value</strong><br>向列表key右边增加元素value  </p>\n<hr>\n<p><strong>lpop key</strong><br>从列表key左边弹出元素<br><strong>rpop key</strong><br>从列表key右边弹出元素  </p>\n<hr>\n<p><strong>llen key</strong><br>统计列表key的元素个数  </p>\n<hr>\n<p><strong>lrange key start stop</strong><br>类似python切片操作，区别是返回包含start与stop为的元素  </p>\n<hr>\n<p><strong>lrem key count value</strong><br>从列表key中前count个数中删除值为value的元素<br>count可以指定为正数或负数，区别是正数从左开始，负数从右开始  </p>\n</blockquote>\n<h1 id=\"集合类型命令\"><a href=\"#集合类型命令\" class=\"headerlink\" title=\"集合类型命令\"></a>集合类型命令</h1><blockquote>\n<p><strong>sadd key member</strong><br>向集合key中添加member元素  </p>\n<hr>\n<p><strong>smembers key</strong><br>获取集合key中的所有元素</p>\n<hr>\n<p><strong>sismember key member</strong><br>判断集合key中是否存在member元素  </p>\n<hr>\n<p><strong>sdiff key1 key2 key3</strong><br>求集合差集key1-key2-key3<br><strong>sinter key1 key2 key3</strong><br>求集合交集<br><strong>sunion key1 key2 key3</strong><br>求集合并集  </p>\n</blockquote>\n<h1 id=\"有序集合类型命令\"><a href=\"#有序集合类型命令\" class=\"headerlink\" title=\"有序集合类型命令\"></a>有序集合类型命令</h1><blockquote>\n<p>一个元素与该元素的分数<br>如果元素的分数相同，Redis会按照元素字典顺序排序<br><strong>zadd key score member</strong><br>向有序集合key中增加成员member分数是score  </p>\n<hr>\n<p><strong>zscore key member</strong><br>获取有序集合key成员member的分数  </p>\n<hr>\n<p><strong>zrange key start stop</strong><br>获取有序集合key中排名在start与stop的元素,有序集合按照分数排名<br><strong>zrange key start stop withscore</strong>  </p>\n<hr>\n<p><strong>zrangescore key min max</strong><br> 获取有序集合key中指定分数范围的元素使用(表示不包含，+inf表示无上限</p>\n<hr>\n<p><strong>zincrby key increment member</strong><br>增加某个元素的分数  </p>\n<hr>\n<p><strong>zrevrangescore key stop start limit offsetr count</strong><br><strong>zrangescore key stop start limit offsetr count</strong><br>两者命令效果相反</p>\n<hr>\n</blockquote>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><blockquote>\n<h2 id=\"命令规范\"><a href=\"#命令规范\" class=\"headerlink\" title=\"命令规范\"></a>命令规范</h2><p><strong>multi</strong>&nbsp;&nbsp;开启事务<br><strong>…….</strong>&nbsp;&nbsp;发送Redis命令<br><strong>exec</strong>&nbsp;&nbsp;执行事务  </p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><ul>\n<li>如果是命令语法错误，执行exec命令后，Redis会直接返回错误，事务中的一条命令都不执行  </li>\n<li>如果是运行时错误，Redis会忽略运行时错误的命令，其余无错误的命令都会执行  </li>\n<li>Redis不支持事务回滚功能  </li>\n</ul>\n</blockquote>\n<h1 id=\"watch命令\"><a href=\"#watch命令\" class=\"headerlink\" title=\"watch命令\"></a>watch命令</h1><blockquote>\n<p>watch命令可以监控一个或多个键，一旦其中一个键在事务开始之前被修改，那么之后的事务就不会执行  </p>\n</blockquote>\n<h1 id=\"过期时间命令\"><a href=\"#过期时间命令\" class=\"headerlink\" title=\"过期时间命令\"></a>过期时间命令</h1><blockquote>\n<p><strong>expire key seconds</strong><br>期望key键在seconds秒后过期(无效)  </p>\n<hr>\n<p><strong>ttl key</strong><br>查看key键还有多少时间过期  </p>\n<hr>\n<p><strong>persist key</strong><br>取消key键的过期时间，注意set命令为键赋值也会清除键的过期时间  </p>\n</blockquote>\n<h1 id=\"排序命令\"><a href=\"#排序命令\" class=\"headerlink\" title=\"排序命令\"></a>排序命令</h1><blockquote>\n<p><strong>sort key</strong><br>对列表类型，集合类型和有序集合进行排序<br>默认是从小到大排序,sort key desc可以从大到小<br><strong>sort tag:ruby:posts by post:*-&gt;time desc</strong><br>根据对象post:*(通配符)的time属性以降序的方式对列表tag:ruby:posts排序  </p>\n<ul>\n<li><blockquote>\n<p>lpush sortlist 1 2 3  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>set item:1 50  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>set item:2 100  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>set item:3 -10  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>sort sortlist by item:* desc  </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>结果&nbsp;&nbsp;2 &nbsp;&nbsp;1&nbsp;&nbsp; 3<br>sort tag:ruby:posts by post:<em>-&gt;time desc get post:</em>-&gt;title get post:<em>-&gt;time<br>根据对象post:</em>(通配符)的time属性以降序的方式对列表tag:ruby:posts排序,同时获取post:<em>-&gt;title和post:</em>-&gt;time  </p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a>任务队列</h1><blockquote>\n<ul>\n<li>松耦合  </li>\n<li>易于扩展<br>使用Redis中队列类型,生产者lpush任务进入队列，消费者rpop获取任务<br><strong>一般消费者使用brpop；brpop当列表中没有元素时会一直阻塞住连接，直到有新元素加入</strong>  </li>\n</ul>\n</blockquote>\n<h1 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h1><blockquote>\n<p>brpop命令可以接受多个键；同时检测多个键，如果所有键都没有元素则阻塞，如果其中有一个键有元素则会从该键中弹出元素，按照从左到右的顺序取键中的元素  </p>\n<ul>\n<li><strong>brpop queue:one queue:two</strong>  </li>\n<li>一旦queue:one键中有元素就会去除queue:one键中的元素，直到queue:one键中无元素才会到queue:two键中取元素，也就是说queue:one的优先级比queue:two高  </li>\n</ul>\n</blockquote>\n<h1 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布/订阅模式\"></a>发布/订阅模式</h1><blockquote>\n<p>Redis提供一组命令可以实现发布/订阅模式<br><strong>publish channel.1 hi</strong><br>向频道channel.1发送hi<br><strong>subscribe channel.1</strong><br>订阅频道channel.1<br>psubscribe命令可以支持正则表达式的形式订阅指定的频道  </p>\n</blockquote>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><blockquote>\n<p> &nbsp; &nbsp; &nbsp; &nbsp;客户端与Redis使用TCP协议连接的，每次执行多个命令时每条命令必须要等待上一条命令执行完才能执行，这样会造成客户端与Redis执行多条命令时有累加时延。  </p>\n<hr>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;为了解决这个问题可以采用管道,一次性发送多条命令并执行完后一次性将每条命令的执行结果返回。<br>&nbsp; &nbsp; &nbsp; &nbsp;管道通过减少客户端与Redis的通信次数来实现降低往返时延累计值的目的。  </p>\n</blockquote>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><blockquote>\n<ul>\n<li><p>将Redis作为数据库使用时，Redis存放在内存中的数据需要持久化到内存，下次Redis重启时还能保证数据有效  </p>\n</li>\n<li><p>将Redis作为缓存服务器使用时，如果缓存被穿透，所有的缓存同时会失效。导致服务无法响应，这是需要将数据持久化到硬盘  </p>\n</li>\n</ul>\n<hr>\n<h2 id=\"缓存设计常见问题\"><a href=\"#缓存设计常见问题\" class=\"headerlink\" title=\"缓存设计常见问题\"></a>缓存设计常见问题</h2><ul>\n<li>缓存穿透<br><strong>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</strong>  </li>\n</ul>\n<p>解决: <strong>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</strong>  </p>\n<hr>\n<ul>\n<li>缓存雪崩<br><strong>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</strong><br>解决:<strong>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</strong>  </li>\n</ul>\n<hr>\n<ul>\n<li>缓存击穿<br><strong>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</strong><br>解决:<strong>1.使用互斥锁(mutex key)2.”提前”使用互斥锁(mutex key)：3. “永远不过期”：</strong>  </li>\n</ul>\n<hr>\n</blockquote>\n<h2 id=\"Redis持久化方式\"><a href=\"#Redis持久化方式\" class=\"headerlink\" title=\"Redis持久化方式\"></a>Redis持久化方式</h2><blockquote>\n<ul>\n<li>RDB方式(快照)<br><strong>1.根据用户配置2.执行save或bgsave3.执行flushall命令</strong></li>\n<li>AOF方式<br><strong>AOF将Redis执行写命令时将数据写入硬盘，会明显降低Redis性能</strong>  </li>\n</ul>\n<h3 id=\"RDB方式\"><a href=\"#RDB方式\" class=\"headerlink\" title=\"RDB方式\"></a>RDB方式</h3><ul>\n<li><p>根据配置规则进行快照(在redis的配置文件中)<br><strong>save 900 1</strong> (表示在900秒有1个或1个以上的键被更改则进行快照)  </p>\n</li>\n<li><p>执行save命令进行快照<br>save命令同步地进行快照操作，同时阻塞所有来自客户端的请求  </p>\n</li>\n<li><p>执行bgsave命令,异步在后台快照，redis可以响应客户端的请求<br>可以通过执行lastsave命令获取最近一次成功执行异步快照的unix时间戳  </p>\n</li>\n<li><p>执行flushall命令,虽然不满足自动快照条件也会强制执行一次快照<br>如果在redis配置文件中没有定义自动快照条件，则不会进行快照  </p>\n</li>\n<li><p>执行复制时，redis配置为主从模式  </p>\n</li>\n<li><p>RDB快照原理<br>redis会fork主进程，在子进程中执行RDB快照，子进程执行快照结束后会将新生成的快照文件替换旧的快照文件，这样可以保证任何时刻，redis的快照文件是完整的（就算是因为当前RDB快照失败，上一次RDB快照文件依然存在）  </p>\n</li>\n</ul>\n<h3 id=\"AOF方式\"><a href=\"#AOF方式\" class=\"headerlink\" title=\"AOF方式\"></a>AOF方式</h3><ul>\n<li><p>redis默认没有开启AOF方式，需要在redis配置文件中增加<strong>appendonly yes</strong>  </p>\n</li>\n<li><p>redis实时将每一条会更改redis中数据的命令写入硬盘的aof文本文件中  </p>\n</li>\n<li><p>为了防止会记录许多的冗余的命令（同一个键被多次更改，实际只要记录最后一次更改的命令即可）<br>在redis配置文件中配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>配置redis在当前AOF文件超过上一次多少百分比是执行重写，同时限制允许重写的最小aof文件大小，防止前期因为文件小造成aof文件反复重写，影响redis性能  </p>\n<ul>\n<li>aof比较影响redis的性能，当丢失的数据会更少  </li>\n</ul>\n<p><strong>redis允许同时开启aof与rdb持久化方式，下一次redis启动时会采用aof文件恢复缓存,因为aof更能保证数据完整性</strong>  </p>\n</blockquote>\n<h1 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h1><blockquote>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><p>Redis提供复制功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上  </p>\n<h2 id=\"Redis配置\"><a href=\"#Redis配置\" class=\"headerlink\" title=\"Redis配置\"></a>Redis配置</h2><p>从数据库Redis配置文件中加入slaveof 主数据库地址 主数据库端口;主数据库无需配置  </p>\n<h2 id=\"哨兵\"><a href=\"#哨兵\" class=\"headerlink\" title=\"哨兵\"></a>哨兵</h2><ul>\n<li><p>监控主数据库和从数据库是否正常运行  </p>\n</li>\n<li><p>主数据库出项故障时自动将从数据库转为主数据库  </p>\n</li>\n<li><p>哨兵是一个独立的进程  </p>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>使用集群只需要将每个数据库节点的cluster-enabled配置项打开即可  </p>\n</li>\n</ul>\n</blockquote>\n","categories":[],"tags":[]},{"title":"jvm笔记","url":"http://yoursite.com/2018/10/31/jvm笔记/","content":"<h1 id=\"Java虚拟机\"><a href=\"#Java虚拟机\" class=\"headerlink\" title=\"Java虚拟机\"></a>Java虚拟机</h1><blockquote>\n<ul>\n<li><strong>jvm内存结构</strong>    </li>\n<li><strong>垃圾回收机制</strong>  </li>\n<li><strong>类加载机制</strong>   </li>\n</ul>\n</blockquote>\n<h1 id=\"jvm内存结构\"><a href=\"#jvm内存结构\" class=\"headerlink\" title=\"jvm内存结构\"></a>jvm内存结构</h1><blockquote>\n<p>jvm将运行时的内存划分为以下几块管理,分别是:  </p>\n<ul>\n<li><strong>程序计数器</strong>  </li>\n<li><strong>虚拟机栈</strong>  </li>\n<li><strong>本地方法栈</strong>  </li>\n<li><strong>堆区</strong>  </li>\n<li><strong>方法区</strong>  </li>\n<li><strong>直接内存</strong>  </li>\n<li><img src=\"jmm.png\" alt=\"内存布局图\"><br>其中程序计数器，虚拟机栈，本地方法栈是线程私有的  <h2 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1.程序计数器\"></a><strong>1.程序计数器</strong></h2>&nbsp;&nbsp;&nbsp;&nbsp;记录当前线程正在执行的Java虚拟机字节码指令的地址;如果当前执行的是本地方法，则为空。  </li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>此内存区域是唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong>  </p>\n<h2 id=\"2-虚拟机栈\"><a href=\"#2-虚拟机栈\" class=\"headerlink\" title=\"2.虚拟机栈\"></a><strong>2.虚拟机栈</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数</strong>、<strong>常量池引用</strong>、<strong>对象引用</strong>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。  </p>\n<ul>\n<li><p><strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</strong>  </p>\n</li>\n<li><p><strong>如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常</strong>  </p>\n</li>\n<li><strong>java -Xss=512M JavaProgram可以指定虚拟机栈内存大小</strong>  <h2 id=\"3-本地方法栈\"><a href=\"#3-本地方法栈\" class=\"headerlink\" title=\"3.本地方法栈\"></a><strong>3.本地方法栈</strong></h2>&nbsp;&nbsp;&nbsp;&nbsp;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务  <h2 id=\"4-堆区\"><a href=\"#4-堆区\" class=\"headerlink\" title=\"4.堆区\"></a><strong>4.堆区</strong></h2></li>\n<li><strong>Java中几乎所有的对象实例都在这里分配内存</strong>  </li>\n<li><strong>Java堆是所有线程共享的一块内存区域，虚拟机启动时创建</strong>  </li>\n<li><strong>堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常</strong>  </li>\n<li><strong>Java 堆不需要连续内存，并且可以动态增加其内存</strong>  </li>\n</ul>\n<p>堆是垃圾收集的主要区域(GC堆),现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把Java堆分成以下三块:<br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>1.新生代(Young Generation)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>2.老年代(Old Generation)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>3.永久代(Permanent Generation)</strong><br><em>永久代也就是jvm规范中定义的方法区，在官方jdk，hotspot中以永久代的形式实现方法区</em>  </p>\n<p>对象被创建时，首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：<br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>1.Eden</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>2.From Survivor</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>3.To Survivor</strong><br><img src=\"heap.gif\" alt=\"堆结构\"><br><strong>java -Xms=1M(初始值) -Xmx=2M(最大值) JavaProgram</strong>  </p>\n<h2 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5.方法区\"></a><strong>5.方法区</strong></h2><ul>\n<li><strong>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>  </li>\n<li><strong>不需要连续的内存，并且可以动态扩展，动态扩展失败会抛出OutOfMemoryError异常</strong>  </li>\n<li><strong>运行时常量池是方法区的一部分</strong><br><em>JDK1.7之前，HotSpot虚拟机把方法区当成永久代来进行垃圾回收，JDK1.8之后，取消了永久代，用 metaspace（元数据）区替代</em><br><em>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池</em>  <h2 id=\"6-直接内存\"><a href=\"#6-直接内存\" class=\"headerlink\" title=\"6.直接内存\"></a><strong>6.直接内存</strong></h2>JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据  </li>\n</ul>\n<p><img src=\"var.jpg\" alt=\"变量\">  </p>\n<h2 id=\"7-堆和栈的区别\"><a href=\"#7-堆和栈的区别\" class=\"headerlink\" title=\"7.堆和栈的区别\"></a><strong>7.堆和栈的区别</strong></h2><p> &nbsp;&nbsp;&nbsp;&nbsp;在方法中定义的一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配，Java在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用  </p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉)  </p>\n</blockquote>\n<h1 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h1><blockquote>\n<p>jvm中程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对Java堆和方法区进行  </p>\n<h2 id=\"1-对象存活判断\"><a href=\"#1-对象存活判断\" class=\"headerlink\" title=\"1.对象存活判断\"></a><strong>1.对象存活判断</strong></h2><ul>\n<li><strong>引用计数算法:</strong> 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题  </li>\n<li><strong>可达性分析算法:</strong> 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收  </li>\n<li>Java虚拟机使用可达性分析算法来判断对象是否可被回收<br><img src=\"gcroot.png\" alt=\"GC\"><br>在Java中GC Roots一般包含以下内容:<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>1.虚拟机栈中引用的对象</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.本地方法栈中引用的对象</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.方法区中类静态属性引用的对象</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.方法区中的常量引用的对象</strong>  <h2 id=\"2-垃圾收集算法\"><a href=\"#2-垃圾收集算法\" class=\"headerlink\" title=\"2.垃圾收集算法\"></a><strong>2.垃圾收集算法</strong></h2><strong>标记-清除算法</strong><br><img src=\"ms.jpg\" alt=\"算法图\"><br>将需要回收的对象进行标记，然后清理掉被标记的对象,不足:  </li>\n<li>标记和清除过程效率都不高  </li>\n<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存  </li>\n</ul>\n<p><strong>标记-整理算法</strong><br><img src=\"mb.jpg\" alt=\"算法图\"><br>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存  </p>\n<p><strong>复制算法</strong><br><img src=\"cp.jpg\" alt=\"算法图\"><br>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。主要不足是只使用了内存的一半<br><em>hotspot虚拟机采用复制算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的Eden空间和两块较小的Survior空间，每次使用 Eden空间和其中一块Survivor在回收时将Eden和 Survivor中还存活着的对象一次性复制到另一块 Survivor空间上，最后清理Eden和使用过的那一块 Survivor。HotSpot虚拟机的Eden和Survivor的大小比例默认为 8:1:1，保证了内存的利用率达到90%.如果每次回收有多于10%的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</em>  </p>\n<h2 id=\"3-分代收集算法\"><a href=\"#3-分代收集算法\" class=\"headerlink\" title=\"3.分代收集算法\"></a><strong>3.分代收集算法</strong></h2><p>jvm堆区分为新生代，老年代，永久代。  </p>\n<ul>\n<li><p>新生代每次垃圾收集时有大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集  </p>\n</li>\n<li><p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收  </p>\n<h2 id=\"4-内存分配与回收机制\"><a href=\"#4-内存分配与回收机制\" class=\"headerlink\" title=\"4.内存分配与回收机制\"></a><strong>4.内存分配与回收机制</strong></h2><p><strong>回收机制</strong><br>对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中(例如大对象)  </p>\n</li>\n</ul>\n<p>jvm内存回收分为三种，分别是:  </p>\n<ul>\n<li>Minor GC(回收新生代内存)  </li>\n<li>Major GC(回收老年的内存)  </li>\n<li>Full GC(回收整个堆空间内存)  </li>\n</ul>\n<p>Minor GC触发条件：  </p>\n<ul>\n<li>当Eden区满时，触发Minor GC  </li>\n</ul>\n<p><strong>因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快</strong>  </p>\n<p>Full GC触发条件:  </p>\n<ul>\n<li>1.调用System.gc时，系统建议执行Full GC，但是不必然执行  </li>\n<li>2.老年代空间不足  </li>\n<li>3.方法区空间不足  </li>\n<li>4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存  </li>\n<li>5.由Eden区、From Survivor区向To Survivor区复制时，对象大小大于To Survivor可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小  </li>\n</ul>\n<p><strong>Full GC 很少执行，而且执行速度会比 Minor GC 慢很多</strong>  </p>\n<p><strong>分配机制</strong>  </p>\n<ul>\n<li>对象优先在 Eden 分配  </li>\n<li>大对象直接进入老年代  </li>\n<li>长期存活的对象进入老年代(为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动到Survivor中，年龄就增加1岁，增加到一定年龄则移动到老年代中)  </li>\n<li>动态对象年龄判定  </li>\n<li>空间分配担保  <h2 id=\"5-垃圾收集器\"><a href=\"#5-垃圾收集器\" class=\"headerlink\" title=\"5.垃圾收集器\"></a><strong>5.垃圾收集器</strong></h2>垃圾收集器是jvm中内存回收的具体实现  </li>\n<li><p>Serial收集器<br>串行收集器只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-整理;垃圾收集的过程中会Stop The World(服务暂停)<br><img src=\"Serial.jpg\" alt=\"图片\">  </p>\n</li>\n<li><p>ParNew收集器<br>Serial 收集器的多线程版本<br><img src=\"ParNew.jpg\" alt=\"图片\">  </p>\n</li>\n<li><p>Parallel Scavenge收集器<br>与ParNew一样是并行的多线程收集器<br>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  </p>\n</li>\n<li><p>CMS收集器<br>并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行<br><img src=\"CMS.jpg\" alt=\"图片\"><br>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿<br>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿<br>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿<br>并发清除：不需要停顿  </p>\n</li>\n<li>G1(Garbage-First)收集器<br>Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收<br>G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离<br><img src=\"G1-heap-allocation.png\" alt=\"图片\"><br>通过记录每个 Region 记录垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region  </li>\n</ul>\n<p><img src=\"gc.jpg\" alt=\"图片\"><br>HotSpot 虚拟机中的7个垃圾收集器，连线表示垃圾收集器可以配合使用  </p>\n</blockquote>\n<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><blockquote>\n<h2 id=\"1-类的生命周期\"><a href=\"#1-类的生命周期\" class=\"headerlink\" title=\"1.类的生命周期\"></a><strong>1.类的生命周期</strong></h2><ul>\n<li>加载<br>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据</li>\n<li>验证<br>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全  </li>\n<li>准备<br>为类的静态变量分配内存，并将其初始化为默认值  </li>\n<li>解析<br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行(<em>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</em>)  </li>\n<li>初始化<br>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：1.声明类变量是指定初始值<br>2.使用静态代码块为类变量指定初始值  </li>\n<li>使用<br>开始使用类</li>\n<li>卸载<br>在如下几种情况下，Java虚拟机将结束生命周期:1.执行了System.exit()方法;2.程序正常执行结束;3.程序在执行过程中遇到了异常或错误而异常终止;4.由于操作系统出现错误而导致Java虚拟机进程终止<br>类加载有三种方式：<br>1、命令行启动应用时候由JVM初始化加载<br>2、通过Class.forName()方法动态加载<br>3、通过ClassLoader.loadClass()方法动态加载<br>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块<br>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块  <h2 id=\"2-双亲委派模型\"><a href=\"#2-双亲委派模型\" class=\"headerlink\" title=\"2.双亲委派模型\"></a><strong>2.双亲委派模型</strong></h2>&nbsp;&nbsp;&nbsp;&nbsp;双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类  </li>\n</ul>\n<p>双亲委派机制:  </p>\n<ul>\n<li>1.当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成  </li>\n<li>2.当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成  </li>\n<li>3.如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载  </li>\n<li>4.若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException  </li>\n</ul>\n<p><img src=\"classloader.PNG\" alt=\"图片\"><br><em>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的</em>  </p>\n<p><img src=\"java.PNG\" alt=\"图片\">  </p>\n</blockquote>\n","categories":[],"tags":[]},{"title":"netty笔记","url":"http://yoursite.com/2018/10/31/netty笔记/","content":"<h2 id=\"netty\"><a href=\"#netty\" class=\"headerlink\" title=\"netty\"></a>netty</h2><blockquote>\n<ul>\n<li><p>netty由JBOSS提供的一个Java开源框架  </p>\n</li>\n<li><p>提供异步的、事件驱动的网络应用程序框架和工具  </p>\n</li>\n<li><p>快速开发高性能、高可靠性的网络服务器和客户端程序  </p>\n</li>\n<li><p>Netty是一个基于NIO的客户、服务器端编程框架  </p>\n</li>\n<li><p>提供了多种协议的编解码包括HTTP、二进制和Google Protobuf等等，它们通过Codec Framework进行整合  </p>\n</li>\n<li><p><a href=\"https://github.com/siwanghu/Netty\" target=\"_blank\" rel=\"noopener\">demo例程</a>  </p>\n</li>\n<li><p><a href=\"https://waylau.com/netty-4-user-guide/Preface/The%20Problem.html\" target=\"_blank\" rel=\"noopener\">学习网站</a>  </p>\n</li>\n<li><p><a href=\"https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/\" target=\"_blank\" rel=\"noopener\">学习资料</a>  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><blockquote>\n<p>NIO 提供了一个所有I/O 操作的全异步的实现。它利用了自NIO 子系统被引入JDK 1.4 时便<br>可用的基于选择器的API。选择器背后的基本概念是充当一个注册表，在那里你将可以请求在Channel 的状态发生变化时得到通知。可能的状态变化有：  </p>\n<ul>\n<li>新的Channel 已被接受并且就绪OP_ACCEPT  </li>\n<li>Channel 连接已经完成OP_CONNECT  </li>\n<li>Channel 有已经就绪的可供读取的数据OP_READ  </li>\n<li>Channel 可用于写数据OP_WRITE  </li>\n</ul>\n<p><img src=\"netty6.PNG\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><blockquote>\n<p><img src=\"netty1.PNG\" alt=\"图片\">  </p>\n<p>Channel是Netty的核心概念之一，它是Netty网络通信的主体，由它负责同对端进行网络通信、注册和数据操作等功能  </p>\n<ul>\n<li><p>一旦用户端连接成功，将新建一个channel同该用户端进行绑定  </p>\n</li>\n<li><p>channel从EventLoopGroup获得一个EventLoop，并注册到该EventLoop，channel生命周期内都和该EventLoop在一起（注册时获得selectionKey）  </p>\n</li>\n<li><p>channel同用户端进行网络连接、关闭和读写，生成相对应的event（改变selectinKey信息），触发eventloop调度线程进行执行  </p>\n</li>\n<li><p>如果是读事件，执行线程调度pipeline来处理用户业务逻辑  </p>\n</li>\n</ul>\n<p>多个channel可以注册到一个eventloop上，所有的操作都是顺序执行的，eventloop会依据channel的事件调用channel的方法进行相关操作，每个channel的操作和处理在eventloop中都是顺序的  </p>\n<p><img src=\"netty2.PNG\" alt=\"图片\">  </p>\n</blockquote>\n<h2 id=\"ChannelPipeline和ChannelHandler\"><a href=\"#ChannelPipeline和ChannelHandler\" class=\"headerlink\" title=\"ChannelPipeline和ChannelHandler\"></a>ChannelPipeline和ChannelHandler</h2><blockquote>\n<ul>\n<li><p>ChannelPipeline和ChannelHandler用于channel事件的拦截和处理  </p>\n</li>\n<li><p>Netty使用类似责任链的模式来设计ChannelPipeline和ChannelHandler  </p>\n</li>\n<li><p>ChannelPipeline相当于ChannelHandler的容器，channel事件消息在ChannelPipeline中流动和传播，相应的事件能够被ChannelHandler拦截处理、传递、忽略或者终止  </p>\n</li>\n</ul>\n<p><img src=\"netty3.PNG\" alt=\"图片\">  </p>\n<ul>\n<li>inbound:当发生某个I/O操作时由IO线程流向用户业务处理线程的事件，如链路建立、链路关闭或者读完成等  </li>\n<li>outbound:由用户线程或者代码发起的IO操作事件  </li>\n</ul>\n</blockquote>\n<h2 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h2><blockquote>\n<ul>\n<li><p>每个ChannelHandler 被添加到ChannelPipeline 后，都会创建一个ChannelHandlerContext 并与之创建的ChannelHandler 关联绑定  </p>\n</li>\n<li><p>ChannelHandler通过ChannelHandlerContext来操作channel和channelpipeline  </p>\n</li>\n</ul>\n<p><img src=\"netty4.PNG\" alt=\"图片\">  </p>\n<ul>\n<li><p>ChannelHandler负责I/O事件或者I/O操作进行拦截和处理，用户可以通过ChannelHandlerAdapter来选择性的实现自己感兴趣的事件拦截和处理  </p>\n</li>\n<li><p>由于Channel只负责实际的I/O操作，因此数据的编解码和实际处理都需要通过ChannelHandler进行处理  </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yinbucheng/article/details/77053692\" target=\"_blank\" rel=\"noopener\">参考例程</a>  </p>\n</li>\n<li><p>ChannelPipeline是线程安全的，多个业务线程可以并发的操作ChannelPipeline；ChannelHandler不是线程安全的，用户需要自己保重ChannelHandler的线程安全  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a>ByteBuffer</h2><blockquote>\n<ul>\n<li><p>在Netty中并没有使用Java自带的ByteBuffer,而是自己实现提供了一个缓存区来用于标识一个字节序列，并帮助用户操作原始字节或者自定义的POJO  </p>\n</li>\n<li><p>channel与对端的I/O读写都要操作Buffers。当有读操作时，把数据从内核区读取到用户区，当有写操作时，把数据从用户区写到内核区  </p>\n</li>\n<li><p>ByteBuf是Netty的实现的最基本的数据缓冲，它包括Heap Buffer和Direct Buffer  </p>\n</li>\n<li><p>ByteBuf实现了高级的功能和API，是Java NIO ByteBuffer更高级的封装和实现  </p>\n</li>\n</ul>\n<p>为了降低分配和释放内存的开销，Netty通过interface ByteBufAllocator 实现了<br>（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的ByteBuf 实例  </p>\n<p><img src=\"netty7.PNG\" alt=\"图片\">  </p>\n<p>使用静态Unpooled缓冲区<br><img src=\"netty8.PNG\" alt=\"图片\">  </p>\n<p>自从Netty 4开始，对象的生命周期由它们的引用计数（reference counts）管理，而不是由垃圾收集器（garbage collector）管理了。ByteBuf是最值得注意的，它使用了引用计数来改进分配内存和释放内存的性能。必须显示的使用:  </p>\n<p><strong>ReferenceCountUtil.release(msg)</strong> 接口释放不用的msg内存  </p>\n</blockquote>\n<h2 id=\"EventLoop和EventLoopGroup\"><a href=\"#EventLoop和EventLoopGroup\" class=\"headerlink\" title=\"EventLoop和EventLoopGroup\"></a>EventLoop和EventLoopGroup</h2><blockquote>\n<p><img src=\"netty5.PNG\" alt=\"图片\">  </p>\n<ul>\n<li><p>EventLoopGroup 负责为每个新创建的Channel 分配一个EventLoop。在当前实现中，<br>使用顺序循环（round-robin）的方式进行分配以获取一个均衡的分布，并且相同的EventLoop<br>可能会被分配给多个Channel  </p>\n</li>\n<li><p>一旦一个Channel 被分配给一个EventLoop，它将在它的整个生命周期中都使用这个<br>EventLoop（以及相关联的Thread）。请牢记这一点，因为它可以使你从担忧你的Channel-<br>Handler 实现中的线程安全和同步问题中解脱出来  </p>\n</li>\n<li><p>另外，需要注意的是，EventLoop 的分配方式对ThreadLocal 的使用的影响。因为一个<br>EventLoop 通常会被用于支撑多个Channel，所以对于所有相关联的Channel 来说，<br>ThreadLocal 都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而，<br>在一些无状态的上下文中，它仍然可以被用于在多个Channel 之间共享一些重度的或者代价昂<br>贵的对象，甚至是事件  </p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"业务代码\"><a href=\"#业务代码\" class=\"headerlink\" title=\"业务代码\"></a>业务代码</h2><blockquote>\n<ul>\n<li><p>耗时的业务代码放入自定义线程池去执行  </p>\n</li>\n<li><p>业务代码里面调用write方法，netty会把你要写出去的消息放入他的对接，然后依靠调度将消息写出去，你只需要write  </p>\n</li>\n<li><p>Netty其实是允许在非NIO线程中写消息的。如果当前是在NIO线程，就直接写过去，如果不在NIO线程，写消息操作会被封装成一个task，然后再由NIO线程池来处理  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</span><br><span class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class=\"line\">        final Object m = pipeline.touch(msg, next);</span><br><span class=\"line\">        EventExecutor executor = next.executor();</span><br><span class=\"line\">        if (executor.inEventLoop()) &#123;</span><br><span class=\"line\">            if (flush) &#123;</span><br><span class=\"line\">                next.invokeWriteAndFlush(m, promise);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                next.invokeWrite(m, promise);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            AbstractWriteTask task;</span><br><span class=\"line\">            if (flush) &#123;</span><br><span class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class=\"line\">            &#125;  else &#123;</span><br><span class=\"line\">                task = WriteTask.newInstance(next, m, promise);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            safeExecute(executor, task, promise, m);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n</blockquote>\n","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]}]